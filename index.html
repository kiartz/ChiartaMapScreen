<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper – Snap</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --acc:#45b8ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:320px; display:flex; flex-direction:column; gap:12px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }

    /* Viewport / Canvas */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action:none; }
    #screen { position:absolute; left:10px; top:10px; background:#0c0d11; border:1px solid #1e2229; touch-action:none; -webkit-user-select:none; user-select:none; }
    /* Grid di sfondo 100px del CANVAS */
    #screen::before {
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px;
    }

    /* Composizione (rettangoli trascinabili) */
    .comp { position:absolute; border:2px dashed var(--acc); background:rgba(69,184,255,0.10);
            cursor:grab; touch-action:none; user-select:none;
            background-image:
              linear-gradient(to right, rgba(69,184,255,0.35) 1px, transparent 1px),
              linear-gradient(to bottom, rgba(69,184,255,0.35) 1px, transparent 1px);
            background-size:128px 128px, 128px 128px; }
    .comp.dragging { cursor:grabbing; }
    .comp * { pointer-events:none; }

    label{display:block;font-size:12px;color:#cfd3d7;margin:0 0 4px}
    input,button{border-radius:8px;border:1px solid var(--border);background:#0f1115;color:var(--ink);padding:8px}
    button{background:var(--acc);color:#001018;font-weight:700;cursor:pointer}
  </style>
</head>
<body>
  <header>
    <div style="font-weight:800">LEDWall Mapper – Snap</div>
  </header>

  <main>
    <section id="left">
      <div class="panel">
        <div style="font-weight:700; margin-bottom:8px">Canvas</div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px">
          <div>
            <label for="canvasW">Larghezza (px)</label>
            <input id="canvasW" type="number" min="1" step="1" value="1920">
          </div>
          <div>
            <label for="canvasH">Altezza (px)</label>
            <input id="canvasH" type="number" min="1" step="1" value="1080">
          </div>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="applyCanvas" style="flex:1">Applica</button>
          <button id="fit" style="flex:1; background:#0f1115; color:var(--ink)">Fit</button>
        </div>
        <div style="margin-top:8px;font-size:12px;color:#a0a6ad">Canvas attuale: <span id="canvasInfo">–</span></div>
      </div>

      <div class="panel">
        <div style="font-weight:700; margin-bottom:8px">Composizione (mattonelle + pixel)</div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px">
          <div>
            <label for="cols">Colonne (mattonelle)</label>
            <input id="cols" type="number" min="1" step="1" value="8">
          </div>
          <div>
            <label for="rows">Righe (mattonelle)</label>
            <input id="rows" type="number" min="1" step="1" value="4">
          </div>
          <div>
            <label for="tileW">Tile W (px)</label>
            <input id="tileW" type="number" min="1" step="1" value="128">
          </div>
          <div>
            <label for="tileH">Tile H (px)</label>
            <input id="tileH" type="number" min="1" step="1" value="128">
          </div>
        </div>
        <button id="addComp" style="margin-top:8px; width:100%">Aggiungi composizione</button>
        <div style="margin-top:6px;font-size:12px;color:#a0a6ad">TUTTO in pixel interi (nessuna virgola).</div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div>Area di lavoro</div>
        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">Drag fluido (mouse+touch), snap morbido a griglia e ad altri rettangoli.</div>
  </footer>

<script>
(() => {
  // Stato
  const state = {
    canvas: { w:1920, h:1080 },
    scale: 1,
    counter: 0
  };
  // Snap morbido (in pixel del mondo)
  const SNAP_THRESHOLD = 12;

  // DOM
  const viewport = document.getElementById('viewport');
  const screenWrap = document.getElementById('screenWrap');
  const screen = document.getElementById('screen');
  const canvasInfo = document.getElementById('canvasInfo');
  const applyCanvasBtn = document.getElementById('applyCanvas');
  const fitBtn = document.getElementById('fit');
  const canvasWInput = document.getElementById('canvasW');
  const canvasHInput = document.getElementById('canvasH');

  const colsInput = document.getElementById('cols');
  const rowsInput = document.getElementById('rows');
  const tileWInput = document.getElementById('tileW');
  const tileHInput = document.getElementById('tileH');
  const addCompBtn = document.getElementById('addComp');

  // Helpers
  const toInt = (v, fb) => {
    const n = parseInt(String(v).replace(/[^0-9]/g,''),10);
    return Number.isFinite(n) && n>0 ? n : fb;
  };

  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = w + 'px';
    screen.style.height = h + 'px';
    canvasInfo.textContent = `${w}×${h}px`;
    fitToViewport();
  }

  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `scale(${state.scale})`;
  }

  // Drag + Snap
  function makeDraggable(el){
    let drag = null;
    const getPos = (e)=>{ if(e.touches&&e.touches[0]) e=e.touches[0]; return {x:e.clientX,y:e.clientY}; };

    const start = (e)=>{
      e.preventDefault(); e.stopPropagation();
      const p = getPos(e);
      const pg = screen.getBoundingClientRect();
      // coordinate mondo
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const curLeft = parseFloat(el.style.left) || 0;
      const curTop  = parseFloat(el.style.top)  || 0;
      drag = { offsetX: pointerWorldX - curLeft, offsetY: pointerWorldY - curTop };
      el.classList.add('dragging');
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', end);
      window.addEventListener('touchmove', move, { passive:false });
      window.addEventListener('touchend', end);
    };

    const move = (e)=>{
      if(!drag) return; e.preventDefault(); e.stopPropagation();
      const p = getPos(e); const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const w = el.offsetWidth, h = el.offsetHeight;

      // posizione grezza (mondo)
      let nx = pointerWorldX - drag.offsetX;
      let ny = pointerWorldY - drag.offsetY;

      // --- SNAP ALLE ALTRE COMPOSIZIONI (bordi/centri) ---
      const comps = [...document.querySelectorAll('.comp')].filter(n=>n!==el);
      let bestDX = Infinity, bestNX = nx; let bestDY = Infinity, bestNY = ny;
      const L = nx, R = nx + w, CX = nx + w/2;
      const T = ny, B = ny + h, CY = ny + h/2;

      const snapEdgeX = (nx, targetX, edge)=>{
        if (edge==='L') return targetX;               // left → target
        if (edge==='R') return targetX - w;           // right → target
        if (edge==='C') return Math.round(targetX - w/2); // centerX → target
        return nx;
      };
      const snapEdgeY = (ny, targetY, edge)=>{
        if (edge==='T') return targetY;               // top → target
        if (edge==='B') return targetY - h;           // bottom → target
        if (edge==='C') return Math.round(targetY - h/2); // centerY → target
        return ny;
      };

      for (const n of comps){
        const left = parseFloat(n.style.left)||0;
        const top  = parseFloat(n.style.top)||0;
        const nw = n.offsetWidth, nh = n.offsetHeight;
        const targetsX = [left, left+nw, left+nw/2]; // L, R, Cx
        const targetsY = [top, top+nh, top+nh/2];    // T, B, Cy

        // orizzontale: prova ad allineare L,R,CX a ciascun targetX
        for (const tx of targetsX){
          const cands = [ ['L', Math.abs(L-tx)], ['R', Math.abs(R-tx)], ['C', Math.abs(CX-tx)] ];
          for (const [edge,dist] of cands){
            if (dist <= SNAP_THRESHOLD && dist < bestDX){
              bestDX = dist; bestNX = snapEdgeX(nx, tx, edge);
            }
          }
        }
        // verticale: T,B,CY verso ciascun targetY
        for (const ty of targetsY){
          const cands = [ ['T', Math.abs(T-ty)], ['B', Math.abs(B-ty)], ['C', Math.abs(CY-ty)] ];
          for (const [edge,dist] of cands){
            if (dist <= SNAP_THRESHOLD && dist < bestDY){
              bestDY = dist; bestNY = snapEdgeY(ny, ty, edge);
            }
          }
        }
      }
      nx = bestNX; ny = bestNY;

      // --- SNAP MORBIDO ALLA GRIGLIA DEL CANVAS ---
      const tileW = parseInt(el.dataset.tileW || '1', 10) || 1;
      const tileH = parseInt(el.dataset.tileH || '1', 10) || 1;
      const originX = 10, originY = 10; // top-left canvas
      const nearestGX = originX + Math.round((nx - originX)/tileW)*tileW;
      if (Math.abs(nx - nearestGX) <= SNAP_THRESHOLD) nx = nearestGX;
      const nearestGY = originY + Math.round((ny - originY)/tileH)*tileH;
      if (Math.abs(ny - nearestGY) <= SNAP_THRESHOLD) ny = nearestGY;

      // clamp finale entro canvas
      nx = Math.max(10, Math.min(10 + state.canvas.w - w, nx));
      ny = Math.max(10, Math.min(10 + state.canvas.h - h, ny));

      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';
    };

    const end = ()=>{
      drag = null; el.classList.remove('dragging');
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', end);
      window.removeEventListener('touchmove', move);
      window.removeEventListener('touchend', end);
    };

    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start, { passive:false });
  }

  // Aggiunge una composizione: dimensioni = (cols*tileW) × (rows*tileH)
  function addComposition(){
    const cols = toInt(colsInput.value, 1);
    const rows = toInt(rowsInput.value, 1);
    const tileW = toInt(tileWInput.value, 1);
    const tileH = toInt(tileHInput.value, 1);

    const w = cols * tileW;
    const h = rows * tileH;

    const el = document.createElement('div');
    el.className = 'comp';
    el.style.width = w + 'px';
    el.style.height = h + 'px';
    el.style.backgroundSize = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px`;
    // Passo griglia per lo snap
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    // posizione iniziale "a cascata" ma clampata allo screen
    const base = 24 * (state.counter % 10);
    const startX = Math.min(10 + state.canvas.w - w, 10 + base);
    const startY = Math.min(10 + state.canvas.h - h, 10 + base);
    el.style.left = startX + 'px';
    el.style.top  = startY + 'px';

    screen.appendChild(el);
    makeDraggable(el);
    state.counter++;
  }

  // Event wiring
  applyCanvasBtn.addEventListener('click', ()=>{
    const w = toInt(canvasWInput.value, state.canvas.w);
    const h = toInt(canvasHInput.value, state.canvas.h);
    applyCanvasSize(w,h);
  });
  fitBtn.addEventListener('click', fitToViewport);
  addCompBtn.addEventListener('click', addComposition);

  new ResizeObserver(()=>fitToViewport()).observe(viewport);
  window.addEventListener('orientationchange', ()=>setTimeout(fitToViewport,0));

  // Boot
  applyCanvasSize(toInt(canvasWInput.value,1920), toInt(canvasHInput.value,1080));
})();
</script>
</body>
</html>
