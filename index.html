<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper – Cross‑platform</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; }
    * { box-sizing: border-box; }
    html, body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overscroll-behavior: none; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:360px; display:flex; flex-direction:column; gap:12px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }
    h3 { margin:0 0 8px; font-size:16px; }
    label { display:block; margin:6px 0 4px; color:#cfd3d7; }
    input, select, button { border-radius:8px; border:1px solid var(--border); background:#0f1115; color:var(--ink); padding:8px; }
    input[type=number] { width:100%; }
    button { background:var(--acc); color:#001018; font-weight:700; cursor:pointer; }
    button.secondary { background:#0f1115; color:var(--ink); }
    button.warn { background:var(--warn); color:#1a0f00; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    ul { list-style:none; padding:0; margin:0; }
    li { padding:8px 4px; border-top:1px dashed var(--border); display:flex; justify-content:space-between; gap:8px; align-items:center; }

    /* Viewport che scala il canvas per entrare nello spazio disponibile */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; touch-action: none; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action: none; }

    /* Screen: l'area di lavoro in pixel reali */
    #screen { position:absolute; left:10px; top:10px; background:#0c0d11; border:1px solid #1e2229; touch-action: none; -webkit-user-select:none; user-select:none; }
    /* Grid di sfondo 100px */
    #screen::before {
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px;
    }

    /* Composizione */
    .comp { position:absolute; border:2px dashed var(--acc); background:rgba(69,184,255,0.03); cursor:grab; touch-action: none; -webkit-user-select:none; user-select:none; }
    .comp.dragging { cursor:grabbing; }
    .comp.selected { border-color:#7fd0ff; box-shadow:0 0 0 2px rgba(127,208,255,0.25) inset; }
    .comp .name { position:absolute; left:4px; right:4px; text-align:center; font-weight:800; color:#eef6ff; text-shadow:0 1px 2px #000; }
    .comp .info { position:absolute; left:4px; top:4px; font-size:12px; color:#d6e8ff; text-shadow:0 1px 2px #000; }

    .muted { color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <div class="row" style="align-items:center; flex-wrap:wrap">
      <div style="font-weight:800">LEDWall Mapper – Cross‑platform</div>
      <div class="row" style="flex:1; justify-content:flex-end; gap:6px">
        <select id="preset">
          <option value="">Preset</option>
          <option>1280x720</option>
          <option selected>1920x1080</option>
          <option>2560x1440</option>
          <option>3840x2160</option>
          <option>7680x4320</option>
        </select>
        <input id="canvasW" type="number" placeholder="W" />
        <input id="canvasH" type="number" placeholder="H" />
        <button id="apply" class="secondary">Applica</button>
        <button id="fit" class="secondary">Fit</button>
        <button id="zoom1" class="secondary">100%</button>
      </div>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="panel">
        <h3>Nuova / Modifica composizione</h3>
        <label>Nome</label>
        <input id="name" type="text" placeholder="Ledwall Main" />
        <div class="row">
          <div>
            <label>Colonne (C)</label>
            <input id="cols" type="number" min="1" value="12">
          </div>
          <div>
            <label>Righe (R)</label>
            <input id="rows" type="number" min="1" value="6">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Tile W (px)</label>
            <input id="tileW" type="number" min="1" value="128">
          </div>
          <div>
            <label>Tile H (px)</label>
            <input id="tileH" type="number" min="1" value="128">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Pos X</label>
            <input id="posX" type="number" value="0">
          </div>
          <div>
            <label>Pos Y</label>
            <input id="posY" type="number" value="0">
          </div>
        </div>
        <div class="row">
          <button id="add">Aggiungi</button>
          <button id="update" class="secondary">Aggiorna</button>
        </div>
      </div>

      <div class="panel">
        <h3>Composizioni</h3>
        <ul id="list"></ul>
        <div class="row" style="margin-top:8px">
          <button id="save" class="secondary">Salva</button>
          <button id="load" class="secondary">Carica</button>
          <button id="clear" class="warn">Nuovo</button>
        </div>
      </div>

      <div class="panel">
        <h3>Opzioni</h3>
        <label><input id="snap" type="checkbox" checked> Snap alla griglia delle tile</label>
        <label><input id="avoidOverlap" type="checkbox" checked> Evita sovrapposizioni</label>
      </div>

      <div class="panel">
        <h3>Info</h3>
        <div id="message" style="min-height:1.2em;color:#9cd1ff"></div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div class="row" style="align-items:center; flex-wrap:wrap">
          <div>Canvas: <span id="canvasInfo">–</span></div>
          <div style="margin-left:auto" class="row">
            <span class="muted">Drag con dito/mouse. Niente sovrapposizioni. Offset rispetto al top-left.</span>
          </div>
        </div>
        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">Build HTML/CSS/JS puro con Pointer Events per compatibilità iPhone + Chrome desktop.</div>
  </footer>

<script>
(() => {
  // ---------- Stato ----------
  const state = {
    canvas: { w: 1920, h: 1080 },
    compositions: [], // {id,name,cols,rows,tileW,tileH,x,y}
    selectedId: null,
    scale: 1,
    dragThreshold: 3, // px per distinguere tap da drag
  };

  // ---------- Helpers DOM ----------
  const $ = (id) => document.getElementById(id);
  const preset = $('preset'), canvasW=$('canvasW'), canvasH=$('canvasH');
  const apply=$('apply'), fit=$('fit'), zoom1=$('zoom1');
  const name=$('name'), cols=$('cols'), rows=$('rows'), tileW=$('tileW'), tileH=$('tileH'), posX=$('posX'), posY=$('posY');
  const add=$('add'), update=$('update');
  const list=$('list'), msg=$('message'), canvasInfo=$('canvasInfo');
  const viewport=$('viewport'), screenWrap=$('screenWrap'), screen=$('screen');
  const saveBtn=$('save'), loadBtn=$('load'), clearBtn=$('clear');
  const snap=$('snap'), avoidOverlap=$('avoidOverlap');

  // ---------- Init canvas ----------
  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = w+"px";
    screen.style.height = h+"px";
    canvasInfo.textContent = `${w}×${h}px`;
    fitToViewport();
  }
  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `scale(${state.scale})`;
  }
  function zoom100(){ state.scale = 1; screenWrap.style.transform = `scale(1)`; }

  // ---------- Utils ----------
  const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
  const bbox = (c) => ({ x:c.x, y:c.y, w:c.cols*c.tileW, h:c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} });
  const clampToCanvas = (b) => b.x>=10 && b.y>=10 && b.x2<=10+state.canvas.w && b.y2<=10+state.canvas.h;
  function overlaps(a,b){ return !(a.x2<=b.x||a.x>=b.x2||a.y2<=b.y||a.y>=b.y2); }
  function collidesAny(id, B){ return state.compositions.some(c => c.id!==id && overlaps(B, bbox(c))); }

  function snapToGrid(x, y, c) {
    if (!snap.checked) return {x, y};
    const gx = c.tileW; const gy = c.tileH;
    const sx = Math.round((x-10) / gx) * gx + 10;
    const sy = Math.round((y-10) / gy) * gy + 10;
    return { x: sx, y: sy };
  }

  // Primo buco L->R, T->B
  function findFirstFit(w,h){
    const maxX = 10 + state.canvas.w - w;
    const maxY = 10 + state.canvas.h - h;
    for (let y=10; y<=maxY; y++){
      for (let x=10; x<=maxX; x++){
        const B = {x,y,w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h}};
        if (!clampToCanvas(B)) continue;
        if (!collidesAny('new', B)) return {x,y};
      }
    }
    return null;
  }

  function rightmost(){
    if (state.compositions.length===0) return null;
    let rm = state.compositions[0], m=bbox(rm).x2;
    for (const c of state.compositions){ const b=bbox(c); if (b.x2>m){ m=b.x2; rm=c; } }
    return bbox(rm);
  }

  // ---------- Render ----------
  function renderAll(){
    for (const el of [...screen.querySelectorAll('.comp')]) el.remove();
    for (const c of state.compositions) renderComp(c);
    refreshList();
  }

  function renderComp(c){
    const b = bbox(c);
    const el = document.createElement('div');
    el.className = 'comp' + (state.selectedId===c.id?' selected':'');
    el.style.left = b.x + 'px';
    el.style.top  = b.y + 'px';
    el.style.width  = b.w + 'px';
    el.style.height = b.h + 'px';
    el.dataset.id = c.id;

    // griglia interna per tile
    el.style.backgroundImage = `
      linear-gradient(to right, #1e3f3f 1px, transparent 1px),
      linear-gradient(to bottom, #1e3f3f 1px, transparent 1px)`;
    el.style.backgroundSize = `${c.tileW}px ${c.tileH}px, ${c.tileW}px ${c.tileH}px`;

    const info = document.createElement('div');
    info.className = 'info';
    info.textContent = `${b.w}×${b.h}px • (${c.x-10},${c.y-10})`;
    el.appendChild(info);

    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    const fs = Math.max(16, Math.min(96, Math.floor(Math.min(b.w,b.h)*0.22)));
    nameEl.style.fontSize = fs + 'px';
    nameEl.style.top = `calc(50% - ${fs/2}px)`;
    nameEl.textContent = c.name;
    el.appendChild(nameEl);

    // interazioni
    el.addEventListener('pointerdown', (e)=> startDrag(e, c.id), { passive: false });
    el.addEventListener('click', ()=> select(c.id));

    screen.appendChild(el);
  }

  function refreshList(){
    list.innerHTML = '';
    for (const c of state.compositions){
      const li = document.createElement('li');
      const left = document.createElement('div');
      const b = bbox(c);
      left.innerHTML = `<div style="font-weight:700; cursor:pointer">${c.name}</div>
        <div style="color:#9cb3c9; font-size:12px">${c.cols}×${c.rows} @ ${c.tileW}×${c.tileH}px — ${b.w}×${b.h}px — pos (${c.x-10},${c.y-10})</div>`;
      left.firstChild.onclick = ()=> select(c.id);
      const right = document.createElement('div');
      const dup = document.createElement('button'); dup.textContent='Duplica'; dup.className='secondary'; dup.onclick=()=> duplicate(c.id);
      const del = document.createElement('button'); del.textContent='Elimina'; del.className='warn'; del.onclick=()=> remove(c.id);
      right.append(dup, del);
      li.append(left, right);
      if (state.selectedId===c.id) li.style.outline='2px solid #3aa';
      list.append(li);
    }
  }

  // ---------- Drag universale (desktop + iPhone) ----------
  let drag = null; // { id, dx, dy, el, pointerId, startX, startY, moved }
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && (navigator.maxTouchPoints||0) > 1);

  function pointerToCanvas(e) {
    const vp = viewport.getBoundingClientRect();
    const x = (e.clientX - vp.left) / state.scale;
    const y = (e.clientY - vp.top)  / state.scale;
    return { x, y };
  }

  function startDrag(e, id) {
    e.preventDefault(); // evita scrolling/zoom del browser
    select(id);
    const comp = state.compositions.find(x => x.id === id);
    const pt = pointerToCanvas(e);
    drag = {
      id,
      dx: pt.x - comp.x,
      dy: pt.y - comp.y,
      el: e.currentTarget,
      pointerId: e.pointerId,
      startX: pt.x,
      startY: pt.y,
      moved: false,
    };
    drag.el.classList.add('dragging');
    if (!isIOS) drag.el.setPointerCapture?.(e.pointerId);
    document.addEventListener('pointermove', onDragMove, { passive: false, capture: true });
    document.addEventListener('pointerup', onDragEnd,   { passive: false, capture: true });
    document.addEventListener('pointercancel', onDragEnd, { passive: false, capture: true });
    document.addEventListener('lostpointercapture', onDragEnd, { passive: false, capture: true });
  }

  let raf = null;
  function onDragMove(e) {
    if (!drag) return;
    if (drag.pointerId != null && e.pointerId !== drag.pointerId) return; // ignora altre dita
    e.preventDefault();
    const comp = state.compositions.find(x => x.id === drag.id);
    const pt = pointerToCanvas(e);

    if (!drag.moved && (Math.abs(pt.x - drag.startX) > state.dragThreshold || Math.abs(pt.y - drag.startY) > state.dragThreshold)) {
      drag.moved = true;
    }

    // aggiorna via rAF per fluidità
    if (raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      let nx = Math.round(pt.x - drag.dx);
      let ny = Math.round(pt.y - drag.dy);

      // snap opzionale
      ({x:nx, y:ny} = snapToGrid(nx, ny, comp));

      // vincoli ai bordi
      const w = comp.cols * comp.tileW, h = comp.rows * comp.tileH;
      nx = Math.max(10, Math.min(10 + state.canvas.w - w, nx));
      ny = Math.max(10, Math.min(10 + state.canvas.h - h, ny));

      comp.x = nx; comp.y = ny;
      if (drag.el) {
        drag.el.style.left = nx + 'px';
        drag.el.style.top  = ny + 'px';
        const info = drag.el.querySelector('.info');
        if (info) info.textContent = `${w}×${h}px • (${nx-10},${ny-10})`;
      }
    });
  }

  function onDragEnd(e) {
    if (!drag) return;
    if (drag.el && drag.pointerId != null && !isIOS) drag.el.releasePointerCapture?.(drag.pointerId);
    drag.el?.classList.remove('dragging');
    document.removeEventListener('pointermove', onDragMove, true);
    document.removeEventListener('pointerup', onDragEnd, true);
    document.removeEventListener('pointercancel', onDragEnd, true);
    document.removeEventListener('lostpointercapture', onDragEnd, true);

    const id = drag.id;
    const moved = drag.moved;
    drag = null;

    if (!moved) { return; } // tratta come semplice tap: niente snap/collisione

    // verifica collisioni/fuori canvas a fine drag
    const c = state.compositions.find(x => x.id === id);
    const b = { x:c.x, y:c.y, w:c.cols*c.tileW, h:c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };

    if (avoidOverlap.checked && state.compositions.some(o => o.id !== id && !(b.x2<=o.x || b.x>=o.x+o.cols*o.tileW || b.y2<=o.y || b.y>=o.y+o.rows*o.tileH))) {
      const fit = findFirstFit(b.w, b.h);
      if (fit) { c.x = fit.x; c.y = fit.y; }
    }
    renderAll();
  }

  // ---------- CRUD composizioni ----------
  function select(id){
    state.selectedId = id;
    const c = state.compositions.find(x=>x.id===id);
    if (c){
      name.value=c.name; rows.value=c.rows; cols.value=c.cols; tileW.value=c.tileW; tileH.value=c.tileH;
      posX.value=c.x-10; posY.value=c.y-10;
    }
    renderAll();
  }
  function addComp(){
    const r=+rows.value, c=+cols.value, tw=+tileW.value, th=+tileH.value; const nm=(name.value||'Composizione').trim();
    if (!r||!c||!tw||!th) { msg.textContent='❌ R,C,tileW,tileH richiesti'; return; }
    const w=c*tw, h=r*th;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10+(+posX.value||0), y:10+(+posY.value||0) };
    let B = { x:pt.x, y:pt.y, w, h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(B) || collidesAny('new', B)){
      const fit = findFirstFit(w,h);
      if (!fit) { msg.textContent='❌ Nessuno spazio libero nel canvas'; return; }
      B.x = fit.x; B.y = fit.y;
    }
    const comp = { id:uid(), name:nm, cols:c, rows:r, tileW:tw, tileH:th, x:B.x, y:B.y };
    state.compositions.push(comp);
    state.selectedId = comp.id;
    renderAll();
    msg.textContent = `✅ Aggiunta ${comp.name}`;
  }
  function updateComp(){
    const id = state.selectedId; if (!id){ msg.textContent='Seleziona una composizione.'; return; }
    const c = state.compositions.find(x=>x.id===id);
    const nv = {
      name:(name.value||c.name).trim(),
      cols:+cols.value||c.cols,
      rows:+rows.value||c.rows,
      tileW:+tileW.value||c.tileW,
      tileH:+tileH.value||c.tileH,
      x:10 + (+posX.value||0),
      y:10 + (+posY.value||0)
    };
    const b = { x:nv.x, y:nv.y, w:nv.cols*nv.tileW, h:nv.rows*nv.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(b) || (avoidOverlap.checked && collidesAny(id,b))) { msg.textContent='❌ Sovrapposizione o fuori canvas'; return; }
    Object.assign(c, nv);
    renderAll(); msg.textContent='✅ Aggiornata';
  }
  function duplicate(id){
    const src = state.compositions.find(x=>x.id===id);
    const w=src.cols*src.tileW, h=src.rows*src.tileH;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10, y:10 };
    let B = { x:pt.x, y:pt.y, w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(B) || collidesAny('new',B)){
      const fit = findFirstFit(w,h);
      if (!fit) { msg.textContent='❌ Nessuno spazio libero nel canvas'; return; }
      B.x=fit.x; B.y=fit.y;
    }
    const nc = { ...src, id:uid(), name:src.name+' Copy', x:B.x, y:B.y };
    state.compositions.push(nc); state.selectedId=nc.id; renderAll();
  }
  function remove(id){ state.compositions = state.compositions.filter(x=>x.id!==id); if (state.selectedId===id) state.selectedId=null; renderAll(); }

  // ---------- Persistenza ----------
  saveBtn.onclick = () => { localStorage.setItem('ledwall.cross.project', JSON.stringify(state)); msg.textContent='💾 Salvato'; };
  loadBtn.onclick = () => {
    const raw = localStorage.getItem('ledwall.cross.project');
    if (!raw) { msg.textContent='Nessun salvataggio.'; return; }
    const data = JSON.parse(raw);
    Object.assign(state, data);
    applyCanvasSize(state.canvas.w, state.canvas.h);
    renderAll(); msg.textContent='✅ Caricato';
  };
  clearBtn.onclick = () => { state.compositions=[]; state.selectedId=null; renderAll(); msg.textContent='✅ Nuovo'; };

  // ---------- Event wiring ----------
  preset.onchange = () => { if(!preset.value) return; const [w,h] = preset.value.split('x').map(Number); canvasW.value=w; canvasH.value=h; };
  apply.onclick = () => { const w=+canvasW.value||1920, h=+canvasH.value||1080; applyCanvasSize(w,h); };
  fit.onclick = fitToViewport; zoom1.onclick = zoom100;
  add.onclick = addComp; update.onclick = updateComp;

  // ---------- Resize observer ----------
  const ro = new ResizeObserver(() => fitToViewport());
  ro.observe(viewport);
  window.addEventListener('orientationchange', () => setTimeout(fitToViewport, 0));

  // ---------- Boot ----------
  canvasW.value = state.canvas.w; canvasH.value = state.canvas.h;
  applyCanvasSize(state.canvas.w, state.canvas.h);
  renderAll();
})();
</script>
</body>
</html>
