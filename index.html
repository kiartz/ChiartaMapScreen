<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>LEDWall Mapper (MVP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#111; --fg:#eee; --muted:#888; --acc:#3aa; --warn:#c93; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header, footer { padding:8px 12px; background:#0b0b0b; position:sticky; top:0; z-index:10; }
    main { display:flex; gap:10px; padding:10px; }
    .panel { background:#151515; border:1px solid #222; border-radius:8px; padding:10px; }
    #left { width:340px; display:flex; flex-direction:column; gap:10px; }
    #canvasWrap { flex:1; display:flex; flex-direction:column; gap:8px; min-width:300px; }
    label { display:block; margin:6px 0 2px; color:#ccc; }
    input[type="number"], input[type="text"], select { width:100%; padding:6px; background:#0f0f0f; color:#fff; border:1px solid #333; border-radius:6px; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    button { padding:8px 10px; background:var(--acc); color:#001; border:none; border-radius:6px; font-weight:600; cursor:pointer; }
    button.secondary { background:#222; color:#ddd; border:1px solid #333; }
    button.warn { background:var(--warn); color:#000; }
    ul { list-style:none; padding:0; margin:0; }
    li { display:flex; align-items:center; justify-content:space-between; gap:6px; padding:6px; border-bottom:1px solid #222; }
    .tag { font-size:12px; color:#aaa; }

    #stageHost {
      height: 70vh;
      max-height: 80vh;
      width: 100%;
      overflow: hidden;
      background:#0a0a0a; border:1px solid #222; border-radius:8px; padding:0; position:relative;
      touch-action: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    @media (max-width: 900px) {
      main { flex-direction: column; }
      #left { width: 100%; }
    }
  </style>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
</head>
<body>
<header>
  <div class="row">
    <div style="flex:2">
      <strong>LEDWall Mapper</strong>
      <span class="tag">MVP • multi-composizione • no-overlap</span>
    </div>
    <div class="row" style="flex:3; flex-wrap:wrap; gap:6px">
      <select id="preset">
        <option value="">Preset risoluzione</option>
        <option>1280x720</option>
        <option selected>1920x1080</option>
        <option>2560x1440</option>
        <option>3840x2160</option>
        <option>7680x4320</option>
      </select>
      <input id="canvasW" type="number" min="1" placeholder="Canvas W (px)" />
      <input id="canvasH" type="number" min="1" placeholder="Canvas H (px)" />
      <button id="setCanvas">Applica</button>
      <button id="fit" class="secondary">Fit</button>
      <button id="zoom1" class="secondary">100%</button>
      <button id="exportPNG" class="secondary">PNG</button>
      <button id="exportSVG" class="secondary">SVG</button>
      <button id="exportJSON" class="secondary">JSON</button>
      <button id="exportCSV" class="secondary">CSV</button>
    </div>
  </div>
</header>

<main>
  <section id="left">
    <div class="panel">
      <h3 style="margin:0 0 8px">Nuova / Modifica Composizione</h3>
      <label>Nome</label><input id="name" type="text" placeholder="Ledwall Main" />
      <div class="row">
        <div><label>Colonne (C)</label><input id="cols" type="number" min="1" value="12" /></div>
        <div><label>Righe (R)</label><input id="rows" type="number" min="1" value="6" /></div>
      </div>
      <div class="row">
        <div><label>Tile W (px)</label><input id="tileW" type="number" min="1" value="128" /></div>
        <div><label>Tile H (px)</label><input id="tileH" type="number" min="1" value="128" /></div>
      </div>
      <div class="row">
        <div><label>Pos X</label><input id="posX" type="number" value="0" /></div>
        <div><label>Pos Y</label><input id="posY" type="number" value="0" /></div>
      </div>
      <div class="row">
        <div><label>Pitch (mm)</label><input id="pitch" type="number" step="0.1" placeholder="opzionale" /></div>
        <div><label>Larghezza fisica (m)</label><input id="widthM" type="text" disabled placeholder="auto" /></div>
      </div>
      <div class="row">
        <button id="add">Aggiungi composizione</button>
        <button id="update" class="secondary">Aggiorna composizione</button>
      </div>
    </div>

    <div class="panel">
      <h3 style="margin:0 0 8px">Composizioni</h3>
      <ul id="compositions"></ul>
      <div class="row" style="margin-top:8px">
        <button id="save">Salva progetto</button>
        <button id="load" class="secondary">Carica</button>
        <button id="clear" class="warn">Nuovo</button>
      </div>
    </div>

    <div class="panel">
      <h3 style="margin:0 0 8px">Info</h3>
      <div id="message"></div>
    </div>
  </section>

  <section id="canvasWrap">
    <div class="panel" style="display:flex; flex-direction:column; gap:8px">
      <div class="row" style="align-items:center; flex-wrap:wrap">
        <div>Canvas: <span id="canvasInfo">–</span></div>
        <div class="tag">Drag composizioni • Pinch (2 dita) per zoom/pan • Fit per riquadrare</div>
      </div>
      <div id="stageHost"></div>
    </div>
  </section>
</main>

<footer>
  <span class="tag">Tip: Le composizioni non possono sovrapporsi. L’offset (X,Y) è riferito al top-left del canvas.</span>
</footer>

<script>
(() => {
  // ---- Stato progetto
  const state = {
    projectId: crypto.randomUUID(),
    name: "Project",
    canvas: { width: 1920, height: 1080, background: "#111111" },
    compositions: [],
    selectedId: null,
    version: 1
  };

  // ---- UI refs
  const $ = id => document.getElementById(id);
  const preset = $("preset"), canvasW = $("canvasW"), canvasH = $("canvasH");
  const setCanvasBtn = $("setCanvas");
  const stageHost = $("stageHost"), canvasInfo = $("canvasInfo"), msg = $("message");
  const name = $("name"), rows = $("rows"), cols = $("cols"), tileW = $("tileW"), tileH = $("tileH"), posX = $("posX"), posY = $("posY");
  const pitch = $("pitch"), widthM = $("widthM");
  const addBtn = $("add"), updateBtn = $("update"), list = $("compositions");
  const exportPNG = $("exportPNG"), exportSVG=$("exportSVG"), exportJSON=$("exportJSON"), exportCSV=$("exportCSV");
  const saveBtn=$("save"), loadBtn=$("load"), clearBtn=$("clear");
  const fitBtn = $("fit"), zoom1Btn=$("zoom1");

  // ---- Stage & layers
  let stage, layerBg, layerComps;
  const padding = 10; // bordo canvas nel container Konva

  // Default 1920x1080 e input valorizzati PRIMA di creare lo stage
  (function setDefaultCanvas(){
    const [w,h] = '1920x1080'.split('x').map(Number);
    preset.value = '1920x1080';
    canvasW.value = w; canvasH.value = h;
    state.canvas.width = w; state.canvas.height = h;
  })();

  function initStage() {
    stageHost.innerHTML = "";
    stage = new Konva.Stage({
      width: stageHost.clientWidth,
      height: stageHost.clientHeight || 300,
      container: "stageHost"
    });
    stage.dragDistance(0); // drag immediato
    layerBg = new Konva.Layer(); layerComps = new Konva.Layer();
    stage.add(layerBg); stage.add(layerComps);
    drawBackground();
    stage.draggable(false);

    // Zoom con rotella (tenere premuto Ctrl/Cmd)
    stage.off('wheel');
    stage.on('wheel', (e) => {
      if (!(e.evt.ctrlKey || e.evt.metaKey)) return;
      e.evt.preventDefault();
      const oldScale = stage.scaleX() || 1;
      const pointer = stage.getPointerPosition();
      const scaleBy = 1.05;
      const direction = e.evt.deltaY > 0 ? -1 : 1;
      const newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      zoomAtPointer(newScale, pointer);
    });

    fitStageToHost();
  }

  function drawBackground() {
    layerBg.destroyChildren();
    const bg = new Konva.Rect({ x: padding, y: padding, width: state.canvas.width, height: state.canvas.height, fill: '#0c0c0c', stroke: '#222', strokeWidth: 1 });
    layerBg.add(bg);
    layerBg.draw();
    canvasInfo.textContent = `${state.canvas.width}×${state.canvas.height}px`;
  }

  // ---- Utility
  const snap = v => Math.round(v);
  const bboxOf = (c) => ({ x: c.x, y: c.y, w: c.cols*c.tileW, h: c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} });
  const overlap = (a,b)=>!(a.x2<=b.x||a.x>=b.x2||a.y2<=b.y||a.y>=b.y2);
  function collidesAny(id,b){return state.compositions.some(c=>c.id!==id&&overlap(b,bboxOf(c)));}
  function canvasClamp(b){return b.x>=padding&&b.y>=padding&&b.x2<=padding+state.canvas.width&&b.y2<=padding+state.canvas.height;}
  const pxSize = (c)=>({w:c.cols*c.tileW,h:c.rows*c.tileH});

  function rightmostBBox(){
    if (state.compositions.length===0) return null;
    let rm = state.compositions[0]; let max = bboxOf(rm).x2;
    for (const c of state.compositions){ const b=bboxOf(c); if (b.x2>max){max=b.x2; rm=c;} }
    return bboxOf(rm);
  }

  // SCAN L→R, T→B: trova il primo buco libero che contenga w×h
  function findFirstFit(w, h){
    const maxX = padding + state.canvas.width - w;
    const maxY = padding + state.canvas.height - h;
    for (let y = padding; y <= maxY; y++){
      for (let x = padding; x <= maxX; x++){
        const b = { x, y, w, h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
        if (!canvasClamp(b)) continue;
        const hits = state.compositions.some(c => overlap(b, bboxOf(c)));
        if (!hits) return { x, y };
      }
    }
    return null;
  }

  // ---- Render composizioni
  function renderAll(){
    layerComps.destroyChildren();
    for (const c of state.compositions) renderComposition(c);
    layerComps.draw();
    refreshList();
  }

  function renderComposition(comp){
    const b=bboxOf(comp);
    const group=new Konva.Group({x:b.x,y:b.y,draggable:!comp.locked,id:comp.id});

    const rect=new Konva.Rect({x:0,y:0,width:b.w,height:b.h,stroke: state.selectedId===comp.id?'#7fd':'#3aa',strokeWidth: state.selectedId===comp.id?3:2,dash:[4,4]});
    group.add(rect);

    const size=pxSize(comp);
    const offText=new Konva.Text({x:4,y:4,text:`${size.w}×${size.h}px • (${comp.x-padding},${comp.y-padding})`,fontSize:12,fill:'#ddd'});
    group.add(offText);

    const fontSize=Math.max(16,Math.min(96,Math.floor(Math.min(b.w,b.h)*0.22)));
    const nameText=new Konva.Text({text:comp.name,fontSize:fontSize,fontStyle:'bold',fill:'#eee',x:4,width:b.w-8,align:'center'});
    nameText.y((b.h-nameText.height())/2);
    group.add(nameText);

    // Selezione + avvio drag robusto
    const startDrag = () => { selectComposition(comp.id); group.startDrag(); };
    group.on('pointerdown', startDrag);
    group.on('mousedown', startDrag);

    // Drag libero; validazione a fine drag (evita blocchi su Chrome/Win)
    group.on('dragmove', () => {
      const p = group.position();
      offText.text(`${size.w}×${size.h}px • (${Math.round(p.x)-padding},${Math.round(p.y)-padding})`);
    });
    group.on('dragend', () => {
      const p = group.position();
      const proposed = { x: snap(p.x), y: snap(p.y), w:b.w, h:b.h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
      if (!canvasClamp(proposed) || collidesAny(comp.id, proposed)) {
        group.position({ x: comp.x, y: comp.y });
      } else {
        comp.x = proposed.x; comp.y = proposed.y;
      }
      offText.text(`${size.w}×${size.h}px • (${comp.x-padding},${comp.y-padding})`);
      layerComps.batchDraw();
      refreshList();
    });

    layerComps.add(group);
  }

  // ---- Selezione & lista
  function selectComposition(id){ state.selectedId=id; renderAll(); }

  function refreshList(){
    list.innerHTML = '';
    for (const c of state.compositions){
      const li=document.createElement('li');
      const left=document.createElement('div');
      const size=pxSize(c);
      left.innerHTML=`<strong style="cursor:pointer">${c.name}</strong>
        <div class="tag">${c.cols}×${c.rows} @ ${c.tileW}×${c.tileH}px — ${size.w}×${size.h}px — pos (${c.x-padding},${c.y-padding})</div>`;
      left.querySelector('strong').onclick=()=>selectComposition(c.id);

      const right=document.createElement('div');
      const btnSel=document.createElement('button'); btnSel.textContent='Seleziona'; btnSel.className='secondary'; btnSel.onclick=()=>selectComposition(c.id);
      const btnDup=document.createElement('button'); btnDup.textContent='Duplica'; btnDup.className='secondary'; btnDup.onclick=()=>duplicateComposition(c);
      const btnDel=document.createElement('button'); btnDel.textContent='Elimina'; btnDel.className='warn'; btnDel.onclick=()=>{ state.compositions = state.compositions.filter(x=>x.id!==c.id); if (state.selectedId===c.id) state.selectedId=null; renderAll(); };
      right.append(btnSel, btnDup, btnDel);

      li.append(left,right);
      if (state.selectedId===c.id) li.style.outline='2px solid #3aa';
      list.append(li);
    }
  }

  function duplicateComposition(c){
    const w=c.cols*c.tileW, h=c.rows*c.tileH;
    // tenta a destra del più a destra
    const right = rightmostBBox();
    let target = right ? { x: right.x2 + 0, y: right.y } : { x: padding, y: padding };
    let b = { x: target.x, y: target.y, w, h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!canvasClamp(b) || collidesAny('new', b)) {
      const fit = findFirstFit(w, h);
      if (!fit) { msg.textContent='❌ Nessuno spazio libero nel canvas'; return; }
      b.x = fit.x; b.y = fit.y;
    }
    const nc = { ...structuredClone(c), id: crypto.randomUUID(), name: c.name+" Copy", x:b.x, y:b.y };
    state.compositions.push(nc); state.selectedId = nc.id; renderAll();
  }

  // ---- Create / Update
  function addComposition(){
    const r=parseInt(rows.value,10), c=parseInt(cols.value,10), tw=parseInt(tileW.value,10), th=parseInt(tileH.value,10);
    const nm=(name.value||"Composizione").trim();
    if(!r||!c||!tw||!th){msg.textContent='❌ R,C,tileW,tileH richiesti';return;}
    const w=c*tw, h=r*th;

    // propone a destra del più a destra; se non entra o collide, usa first-fit
    const right = rightmostBBox();
    let base = right ? { x: right.x2 + 0, y: right.y } : { x: padding + parseInt(posX.value||0,10), y: padding + parseInt(posY.value||0,10) };
    let b = { x: snap(base.x), y: snap(base.y), w, h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!canvasClamp(b) || collidesAny('new', b)) {
      const fit = findFirstFit(w, h);
      if (!fit){ msg.textContent='❌ Nessuno spazio libero nel canvas'; return; }
      b.x = fit.x; b.y = fit.y;
    }

    const comp={ id: crypto.randomUUID(), name:nm, rows:r, cols:c, tileW:tw, tileH:th, x:b.x, y:b.y, rotation:0, locked:false, visible:true, pitch: parseFloat(pitch.value)||null };
    state.compositions.push(comp); state.selectedId = comp.id; renderAll();
    msg.textContent=`✅ Aggiunta ${comp.name}`;
  }
  addBtn.onclick=addComposition;

  // ---- Canvas preset/custom
  preset.addEventListener('change', () => {
    if (!preset.value) return;
    const [w,h] = preset.value.split('x').map(Number);
    canvasW.value = w; canvasH.value = h;
  });
  setCanvasBtn.addEventListener('click', () => {
    const w = parseInt(canvasW.value||0,10), h = parseInt(canvasH.value||0,10);
    if (!w||!h) { msg.textContent='❌ Inserisci Canvas W/H'; return; }
    state.canvas.width = w; state.canvas.height = h;
    initStage(); renderAll();
    fitStageToHost();
    msg.textContent='✅ Canvas aggiornato';
  });

  // ---- Export (come prima)
  exportPNG.onclick = () => {
    const oldScale = stage.scaleX() || 1, oldPos = stage.position();
    stage.scale({x:1,y:1}); stage.position({x:0,y:0});
    const dataURL = stage.toDataURL({ pixelRatio: 2 });
    stage.scale({x:oldScale,y:oldScale}); stage.position(oldPos);
    saveAs(dataURL, 'ledwall-mapper.png');
  };
  exportSVG.onclick = () => {
    const svgParts = [];
    const cx = padding, cy = padding, cw = state.canvas.width, ch = state.canvas.height;
    svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${cw}" height="${ch}">`);
    svgParts.push(`<rect x="0" y="0" width="${cw}" height="${ch}" fill="#0c0c0c" />`);
    for (const c of state.compositions) {
      const x = c.x - cx, y = c.y - cy, w = c.cols*c.tileW, h = c.rows*c.tileH;
      svgParts.push(`<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="none" stroke="#3aa" stroke-dasharray="4,4" />`);
      svgParts.push(`<text x="${x+4}" y="${y+14}" fill="#ddd" font-size="12">${w}×${h}px • (${x},${y})</text>`);
      svgParts.push(`<text x="${x}" y="${y + h/2}" fill="#eee" font-size="14" text-anchor="middle" dominant-baseline="middle" transform="translate(${x + w/2},0)">${c.name}</text>`);
    }
    svgParts.push(`</svg>`);
    const blob = new Blob([svgParts.join("")], {type:'image/svg+xml;charset=utf-8'});
    saveAs(blob, 'ledwall-mapper.svg');
  };
  exportJSON.onclick = () => {
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:'application/json'});
    saveAs(blob, 'project.json');
  };
  exportCSV.onclick = () => {
    const rows = [];
    for (const comp of state.compositions) {
      for (let r=0; r<comp.rows; r++) {
        for (let c=0; c<comp.cols; c++) {
          const x = comp.x + c*comp.tileW - padding;
          const y = comp.y + r*comp.tileH - padding;
          rows.push({ projectId: state.projectId, compId: comp.id, compName: comp.name, tileId: `${comp.id}-${r}-${c}`, row: r, col: c, x, y, width: comp.tileW, height: comp.tileH, rotation: 0 });
        }
      }
    }
    const csv = Papa.unparse(rows);
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    saveAs(blob, 'tiles.csv');
  };

  // ---- Persistenza (localStorage)
  function saveAutosafe() { localStorage.setItem('ledwall.project', JSON.stringify(state)); }
  saveBtn.onclick = saveAutosafe;
  loadBtn.onclick = () => {
    const raw = localStorage.getItem('ledwall.project');
    if (!raw) { msg.textContent='Nessun salvataggio trovato.'; return; }
    const data = JSON.parse(raw);
    Object.assign(state, data);
    initStage(); renderAll(); fitStageToHost();
    msg.textContent='✅ Progetto caricato';
  };
  clearBtn.onclick = () => {
    state.projectId = crypto.randomUUID(); state.compositions = []; state.selectedId = null;
    renderAll(); saveAutosafe(); msg.textContent='✅ Nuovo progetto';
  };

  // ---- Fit & zoom helpers
  function fitStageToHost(){
    const hostRect=stageHost.getBoundingClientRect();
    const targetW=state.canvas.width+20; const targetH=state.canvas.height+20;
    const sx=hostRect.width/targetW; const sy=(hostRect.height||1)/targetH;
    const s=Math.min(sx,sy,1);
    stage.scale({x:s,y:s});
    const offsetX=(hostRect.width-targetW*s)/2; const offsetY=(hostRect.height-targetH*s)/2;
    stage.position({x:offsetX,y:offsetY});
    stage.batchDraw();
  }
  function zoomAtPointer(newScale,pointer){
    const oldScale=stage.scaleX()||1;
    const mousePointTo={x:(pointer.x-stage.x())/oldScale,y:(pointer.y-stage.y())/oldScale};
    stage.scale({x:newScale,y:newScale});
    const newPos={x:pointer.x-mousePointTo.x*newScale,y:pointer.y-mousePointTo.y*newScale};
    stage.position(newPos); stage.batchDraw();
  }
  fitBtn.onclick=fitStageToHost; zoom1Btn.onclick=()=>{stage.scale({x:1,y:1});stage.position({x:0,y:0});stage.batchDraw();};

  // ---- Resize observer
  const ro=new ResizeObserver(()=>{ if(!stage) return; stage.size({width:stageHost.clientWidth,height:stageHost.clientHeight||300}); fitStageToHost(); });
  ro.observe(stageHost);

  // ---- Boot
  initStage(); renderAll(); fitStageToHost();
})();
</script>
</body>
</html>
