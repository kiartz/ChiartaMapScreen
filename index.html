<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper â€“ Vanilla</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:360px; display:flex; flex-direction:column; gap:12px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }
    h3 { margin:0 0 8px; font-size:16px; }
    label { display:block; margin:6px 0 4px; color:#cfd3d7; }
    input, select, button { border-radius:8px; border:1px solid var(--border); background:#0f1115; color:var(--ink); padding:8px; }
    input[type=number] { width:100%; }
    button { background:var(--acc); color:#001018; font-weight:700; cursor:pointer; }
    button.secondary { background:#0f1115; color:var(--ink); }
    button.warn { background:var(--warn); color:#1a0f00; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    ul { list-style:none; padding:0; margin:0; }
    li { padding:8px 4px; border-top:1px dashed var(--border); display:flex; justify-content:space-between; gap:8px; align-items:center; }

    /* Viewport che scala il canvas per entrare nello spazio disponibile */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; }

    /* Screen: l'area di lavoro in pixel reali */
    #screen { position:absolute; left:10px; top:10px; background:#0c0d11; border:1px solid #1e2229; }
    /* Grid di sfondo 100px */
    #screen::before {
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px;
    }

    /* Composizione */
    .comp { position:absolute; border:2px dashed var(--acc); background:rgba(69,184,255,0.03); cursor:move; }
    .comp.selected { border-color:#7fd0ff; box-shadow:0 0 0 2px rgba(127,208,255,0.25) inset; }
    /* Griglia interna basata su tile size (impostata inline) */
    .comp .name { position:absolute; left:4px; right:4px; text-align:center; font-weight:800; color:#eef6ff; text-shadow:0 1px 2px #000; }
    .comp .info { position:absolute; left:4px; top:4px; font-size:12px; color:#d6e8ff; text-shadow:0 1px 2px #000; }
  </style>
</head>
<body>
  <header>
    <div class="row" style="align-items:center; flex-wrap:wrap">
      <div style="font-weight:800">LEDWall Mapper â€“ Vanilla</div>
      <div class="row" style="flex:1; justify-content:flex-end; gap:6px">
        <select id="preset">
          <option value="">Preset</option>
          <option>1280x720</option>
          <option selected>1920x1080</option>
          <option>2560x1440</option>
          <option>3840x2160</option>
          <option>7680x4320</option>
        </select>
        <input id="canvasW" type="number" placeholder="W" />
        <input id="canvasH" type="number" placeholder="H" />
        <button id="apply" class="secondary">Applica</button>
        <button id="fit" class="secondary">Fit</button>
        <button id="zoom1" class="secondary">100%</button>
      </div>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="panel">
        <h3>Nuova / Modifica composizione</h3>
        <label>Nome</label>
        <input id="name" type="text" placeholder="Ledwall Main" />
        <div class="row">
          <div>
            <label>Colonne (C)</label>
            <input id="cols" type="number" min="1" value="12">
          </div>
          <div>
            <label>Righe (R)</label>
            <input id="rows" type="number" min="1" value="6">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Tile W (px)</label>
            <input id="tileW" type="number" min="1" value="128">
          </div>
          <div>
            <label>Tile H (px)</label>
            <input id="tileH" type="number" min="1" value="128">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Pos X</label>
            <input id="posX" type="number" value="0">
          </div>
          <div>
            <label>Pos Y</label>
            <input id="posY" type="number" value="0">
          </div>
        </div>
        <div class="row">
          <button id="add">Aggiungi</button>
          <button id="update" class="secondary">Aggiorna</button>
        </div>
      </div>

      <div class="panel">
        <h3>Composizioni</h3>
        <ul id="list"></ul>
        <div class="row" style="margin-top:8px">
          <button id="save" class="secondary">Salva</button>
          <button id="load" class="secondary">Carica</button>
          <button id="clear" class="warn">Nuovo</button>
        </div>
      </div>

      <div class="panel">
        <h3>Info</h3>
        <div id="message" style="min-height:1.2em;color:#9cd1ff"></div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div class="row" style="align-items:center; flex-wrap:wrap">
          <div>Canvas: <span id="canvasInfo">â€“</span></div>
          <div style="margin-left:auto" class="row">
            <span class="muted" style="color:#a0a6ad">Drag, nessuna sovrapposizione, offset riferito al top-left</span>
          </div>
        </div>
        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">Vanilla build: HTML/CSS/JS senza librerie di terze parti per massima compatibilitÃ  desktop/mobile.</div>
  </footer>

<script>
(() => {
  // ---------- Stato ----------
  const state = {
    canvas: { w: 1920, h: 1080 },
    compositions: [], // {id,name,cols,rows,tileW,tileH,x,y}
    selectedId: null,
    scale: 1
  };

  // ---------- Helpers DOM ----------
  const $ = (id) => document.getElementById(id);
  const preset = $('preset'), canvasW=$('canvasW'), canvasH=$('canvasH');
  const apply=$('apply'), fit=$('fit'), zoom1=$('zoom1');
  const name=$('name'), cols=$('cols'), rows=$('rows'), tileW=$('tileW'), tileH=$('tileH'), posX=$('posX'), posY=$('posY');
  const add=$('add'), update=$('update');
  const list=$('list'), msg=$('message'), canvasInfo=$('canvasInfo');
  const viewport=$('viewport'), screenWrap=$('screenWrap'), screen=$('screen');
  const saveBtn=$('save'), loadBtn=$('load'), clearBtn=$('clear');

  // ---------- Init canvas ----------
  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = w+"px";
    screen.style.height = h+"px";
    canvasInfo.textContent = `${w}Ã—${h}px`;
    fitToViewport();
  }
  function fitToViewport(){
    // scala lo screen per entrare nel viewport lasciando 16px di margine
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `scale(${state.scale})`;
  }
  function zoom100(){ state.scale = 1; screenWrap.style.transform = `scale(1)`; }

  // ---------- Utils ----------
  const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
  const bbox = (c) => ({ x:c.x, y:c.y, w:c.cols*c.tileW, h:c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} });
  const clampToCanvas = (b) => b.x>=10 && b.y>=10 && b.x2<=10+state.canvas.w && b.y2<=10+state.canvas.h;
  function overlaps(a,b){ return !(a.x2<=b.x||a.x>=b.x2||a.y2<=b.y||a.y>=b.y2); }
  function collidesAny(id, B){ return state.compositions.some(c => c.id!==id && overlaps(B, bbox(c))); }

  // First-fit scan L->R, T->B
  function findFirstFit(w,h){
    const maxX = 10 + state.canvas.w - w;
    const maxY = 10 + state.canvas.h - h;
    for (let y=10; y<=maxY; y++){
      for (let x=10; x<=maxX; x++){
        const B = {x,y,w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h}};
        if (!clampToCanvas(B)) continue;
        if (!collidesAny('new', B)) return {x,y};
      }
    }
    return null;
  }

  function rightmost(){
    if (state.compositions.length===0) return null;
    let rm = state.compositions[0], m=bbox(rm).x2;
    for (const c of state.compositions){ const b=bbox(c); if (b.x2>m){ m=b.x2; rm=c; } }
    return bbox(rm);
  }

  // ---------- Render ----------
  function renderAll(){
    // pulisci
    for (const el of [...screen.querySelectorAll('.comp')]) el.remove();
    // composizioni
    for (const c of state.compositions) renderComp(c);
    // lista
    refreshList();
  }

  function renderComp(c){
    const b = bbox(c);
    const el = document.createElement('div');
    el.className = 'comp' + (state.selectedId===c.id?' selected':'');
    el.style.left = b.x + 'px';
    el.style.top  = b.y + 'px';
    el.style.width  = b.w + 'px';
    el.style.height = b.h + 'px';
    el.dataset.id = c.id;

    // griglia interna per tile
    el.style.backgroundImage = `
      linear-gradient(to right, #1e3f3f 1px, transparent 1px),
      linear-gradient(to bottom, #1e3f3f 1px, transparent 1px)`;
    el.style.backgroundSize = `${c.tileW}px ${c.tileH}px, ${c.tileW}px ${c.tileH}px`;

    const info = document.createElement('div');
    info.className = 'info';
    info.textContent = `${b.w}Ã—${b.h}px â€¢ (${c.x-10},${c.y-10})`;
    el.appendChild(info);

    const name = document.createElement('div');
    name.className = 'name';
    const fs = Math.max(16, Math.min(96, Math.floor(Math.min(b.w,b.h)*0.22)));
    name.style.fontSize = fs + 'px';
    // centro verticale
    name.style.top = `calc(50% - ${fs/2}px)`;
    name.textContent = c.name;
    el.appendChild(name);

    // interazioni
    el.addEventListener('pointerdown', (e)=> startDrag(e, c.id));
    el.addEventListener('click', ()=> select(c.id));

    screen.appendChild(el);
  }

  function refreshList(){
    list.innerHTML = '';
    for (const c of state.compositions){
      const li = document.createElement('li');
      const left = document.createElement('div');
      const b = bbox(c);
      left.innerHTML = `<div style="font-weight:700; cursor:pointer">${c.name}</div>
        <div style="color:#9cb3c9; font-size:12px">${c.cols}Ã—${c.rows} @ ${c.tileW}Ã—${c.tileH}px â€” ${b.w}Ã—${b.h}px â€” pos (${c.x-10},${c.y-10})</div>`;
      left.firstChild.onclick = ()=> select(c.id);
      const right = document.createElement('div');
      const dup = document.createElement('button'); dup.textContent='Duplica'; dup.className='secondary'; dup.onclick=()=> duplicate(c.id);
      const del = document.createElement('button'); del.textContent='Elimina'; del.className='warn'; del.onclick=()=> remove(c.id);
      right.append(dup, del);
      li.append(left, right);
      if (state.selectedId===c.id) li.style.outline='2px solid #3aa';
      list.append(li);
    }
  }

  // ---------- Drag manuale robusto ----------
  let drag = null; // {id,dx,dy}
  function startDrag(e, id){
    select(id);
    const c = state.compositions.find(x=>x.id===id);
    const b = bbox(c);
    const vpRect = viewport.getBoundingClientRect();
    // posizione puntatore relativa allo screenWrap scalato
    const px = (e.clientX - vpRect.left) / state.scale - 10; // -10 padding
    const py = (e.clientY - vpRect.top)  / state.scale - 10;
    drag = { id, dx: px - c.x + 10, dy: py - c.y + 10 };
    window.addEventListener('pointermove', onDragMove);
    window.addEventListener('pointerup', onDragEnd, { once:true });
  }
  function onDragMove(e){
    if (!drag) return;
    const c = state.compositions.find(x=>x.id===drag.id);
    const vpRect = viewport.getBoundingClientRect();
    const px = (e.clientX - vpRect.left) / state.scale; // coordinate nello spazio screenWrap
    const py = (e.clientY - vpRect.top)  / state.scale;
    let nx = Math.round(px - drag.dx);
    let ny = Math.round(py - drag.dy);
    const b = { x:nx, y:ny, w:c.cols*c.tileW, h:c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    // clamp ai bordi dello screen (ricorda: screen parte a +10,+10)
    if (b.x < 10) b.x = 10;
    if (b.y < 10) b.y = 10;
    if (b.x2 > 10 + state.canvas.w) b.x = 10 + state.canvas.w - b.w;
    if (b.y2 > 10 + state.canvas.h) b.y = 10 + state.canvas.h - b.h;

    // disegna live (anche se magari collide, decidiamo alla fine)
    c.x = b.x; c.y = b.y;
    renderAll();
  }
  function onDragEnd(){
    const id = drag?.id; drag=null;
    if (!id) return;
    const c = state.compositions.find(x=>x.id===id);
    const b = bbox(c);
    if (collidesAny(id, b)){
      // ripristina all'ultimo valido (semplice: sposta di 0 fino a libero)
      const prev = findFirstFit(b.w, b.h);
      if (prev){ c.x=prev.x; c.y=prev.y; }
      else msg.textContent = 'âŒ Nessuno spazio libero';
    }
    renderAll();
  }

  // ---------- CRUD composizioni ----------
  function select(id){
    state.selectedId = id;
    const c = state.compositions.find(x=>x.id===id);
    if (c){
      name.value=c.name; rows.value=c.rows; cols.value=c.cols; tileW.value=c.tileW; tileH.value=c.tileH;
      posX.value=c.x-10; posY.value=c.y-10;
    }
    renderAll();
  }
  function addComp(){
    const r=+rows.value, c=+cols.value, tw=+tileW.value, th=+tileH.value; const nm=(name.value||'Composizione').trim();
    if (!r||!c||!tw||!th) { msg.textContent='âŒ R,C,tileW,tileH richiesti'; return; }
    const w=c*tw, h=r*th;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10+(+posX.value||0), y:10+(+posY.value||0) };
    let B = { x:pt.x, y:pt.y, w, h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(B) || collidesAny('new', B)){
      const fit = findFirstFit(w,h);
      if (!fit) { msg.textContent='âŒ Nessuno spazio libero nel canvas'; return; }
      B.x = fit.x; B.y = fit.y;
    }
    const comp = { id:uid(), name:nm, cols:c, rows:r, tileW:tw, tileH:th, x:B.x, y:B.y };
    state.compositions.push(comp);
    state.selectedId = comp.id;
    renderAll();
    msg.textContent = `âœ… Aggiunta ${comp.name}`;
  }
  function updateComp(){
    const id = state.selectedId; if (!id){ msg.textContent='Seleziona una composizione.'; return; }
    const c = state.compositions.find(x=>x.id===id);
    const nv = {
      name:(name.value||c.name).trim(),
      cols:+cols.value||c.cols,
      rows:+rows.value||c.rows,
      tileW:+tileW.value||c.tileW,
      tileH:+tileH.value||c.tileH,
      x:10 + (+posX.value||0),
      y:10 + (+posY.value||0)
    };
    const b = { x:nv.x, y:nv.y, w:nv.cols*nv.tileW, h:nv.rows*nv.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(b) || collidesAny(id,b)) { msg.textContent='âŒ Sovrapposizione o fuori canvas'; return; }
    Object.assign(c, nv);
    renderAll(); msg.textContent='âœ… Aggiornata';
  }
  function duplicate(id){
    const src = state.compositions.find(x=>x.id===id);
    const w=src.cols*src.tileW, h=src.rows*src.tileH;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10, y:10 };
    let B = { x:pt.x, y:pt.y, w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(B) || collidesAny('new',B)){
      const fit = findFirstFit(w,h);
      if (!fit) { msg.textContent='âŒ Nessuno spazio libero nel canvas'; return; }
      B.x=fit.x; B.y=fit.y;
    }
    const nc = { ...src, id:uid(), name:src.name+' Copy', x:B.x, y:B.y };
    state.compositions.push(nc); state.selectedId=nc.id; renderAll();
  }
  function remove(id){ state.compositions = state.compositions.filter(x=>x.id!==id); if (state.selectedId===id) state.selectedId=null; renderAll(); }

  // ---------- Persistenza ----------
  saveBtn.onclick = () => { localStorage.setItem('ledwall.vanilla.project', JSON.stringify(state)); msg.textContent='ðŸ’¾ Salvato'; };
  loadBtn.onclick = () => {
    const raw = localStorage.getItem('ledwall.vanilla.project');
    if (!raw) { msg.textContent='Nessun salvataggio.'; return; }
    const data = JSON.parse(raw);
    Object.assign(state, data);
    applyCanvasSize(state.canvas.w, state.canvas.h);
    renderAll(); msg.textContent='âœ… Caricato';
  };
  clearBtn.onclick = () => { state.compositions=[]; state.selectedId=null; renderAll(); msg.textContent='âœ… Nuovo'; };

  // ---------- Event wiring ----------
  preset.onchange = () => { if(!preset.value) return; const [w,h] = preset.value.split('x').map(Number); canvasW.value=w; canvasH.value=h; };
  apply.onclick = () => { const w=+canvasW.value||1920, h=+canvasH.value||1080; applyCanvasSize(w,h); };
  fit.onclick = fitToViewport; zoom1.onclick = zoom100;
  add.onclick = addComp; update.onclick = updateComp;

  // ---------- Boot ----------
  // default 1920Ã—1080 giÃ  nei campi
  canvasW.value = state.canvas.w; canvasH.value = state.canvas.h;
  applyCanvasSize(state.canvas.w, state.canvas.h);
  renderAll();
})();
</script>
</body>
</html>
