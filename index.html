<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper – Vanilla (drag touch+mouse)</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:360px; display:flex; flex-direction:column; gap:12px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }
    h3 { margin:0 0 8px; font-size:16px; }
    label { display:block; margin:6px 0 4px; color:#cfd3d7; }
    input, select, button { border-radius:8px; border:1px solid var(--border); background:#0f1115; color:var(--ink); padding:8px; }
    input[type=number] { width:100%; }
    button { background:var(--acc); color:#001018; font-weight:700; cursor:pointer; }
    button.secondary { background:#0f1115; color:var(--ink); }
    button.warn { background:var(--warn); color:#1a0f00; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    ul { list-style:none; padding:0; margin:0; }
    li { padding:8px 4px; border-top:1px dashed var(--border); display:flex; justify-content:space-between; gap:8px; align-items:center; }

    /* Viewport che scala il canvas per entrare nello spazio disponibile */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action: none; }

    /* Screen: l'area di lavoro in pixel reali */
    #screen { position:absolute; left:10px; top:10px; background:#0c0d11; border:1px solid #1e2229; touch-action: none; -webkit-user-select:none; user-select:none; }
    /* Grid di sfondo 100px */
    #screen::before {
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px;
    }

    /* Composizione */
    .comp { position:absolute; border:2px dashed var(--acc); background:rgba(69,184,255,0.06); cursor:grab; touch-action:none; -webkit-user-select:none; user-select:none; }
    .comp.dragging { cursor:grabbing; }
    .comp.selected { border-color:#7fd0ff; box-shadow:0 0 0 2px rgba(127,208,255,0.25) inset; }
    /* i figli NON devono intercettare il tocco */
    .comp .name, .comp .info { pointer-events:none; }
    .comp .name { position:absolute; left:4px; right:4px; text-align:center; font-weight:800; color:#eef6ff; text-shadow:0 1px 2px #000; }
    .comp .info { position:absolute; left:4px; top:4px; font-size:12px; color:#d6e8ff; text-shadow:0 1px 2px #000; }
  </style>
</head>
<body>
  <header>
    <div class="row" style="align-items:center; flex-wrap:wrap">
      <div style="font-weight:800">LEDWall Mapper – Vanilla (drag touch+mouse)</div>
      <div class="row" style="flex:1; justify-content:flex-end; gap:6px">
        <select id="preset">
          <option value="">Preset</option>
          <option>1280x720</option>
          <option selected>1920x1080</option>
          <option>2560x1440</option>
          <option>3840x2160</option>
          <option>7680x4320</option>
        </select>
        <input id="canvasW" type="number" placeholder="W" />
        <input id="canvasH" type="number" placeholder="H" />
        <button id="apply" class="secondary">Applica</button>
        <button id="fit" class="secondary">Fit</button>
        <button id="zoom1" class="secondary">100%</button>
      </div>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="panel">
        <h3>Nuova / Modifica composizione</h3>
        <label>Nome</label>
        <input id="name" type="text" placeholder="Ledwall Main" />
        <div class="row">
          <div>
            <label>Colonne (C)</label>
            <input id="cols" type="number" min="1" value="12">
          </div>
          <div>
            <label>Righe (R)</label>
            <input id="rows" type="number" min="1" value="6">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Tile W (px)</label>
            <input id="tileW" type="number" min="1" value="128">
          </div>
          <div>
            <label>Tile H (px)</label>
            <input id="tileH" type="number" min="1" value="128">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Pos X</label>
            <input id="posX" type="number" value="0">
          </div>
          <div>
            <label>Pos Y</label>
            <input id="posY" type="number" value="0">
          </div>
        </div>
        <div class="row">
          <button id="add">Aggiungi</button>
          <button id="update" class="secondary">Aggiorna</button>
        </div>
      </div>

      <div class="panel">
        <h3>Composizioni</h3>
        <ul id="list"></ul>
        <div class="row" style="margin-top:8px">
          <button id="save" class="secondary">Salva</button>
          <button id="load" class="secondary">Carica</button>
          <button id="clear" class="warn">Nuovo</button>
        </div>
      </div>

      <div class="panel">
        <h3>Info</h3>
        <div id="message" style="min-height:1.2em;color:#9cd1ff"></div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div class="row" style="align-items:center; flex-wrap:wrap">
          <div>Canvas: <span id="canvasInfo">–</span></div>
          <div style="margin-left:auto" class="row">
            <span class="muted" style="color:#a0a6ad">Drag con dito/mouse. Offset rispetto al top-left.</span>
          </div>
        </div>
        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">Mouse + Touch events, niente Pointer Events → stabile su iPhone e Chrome desktop.</div>
  </footer>

<script>
(() => {
  // ---------- Stato ----------
  const state = {
    canvas: { w: 1920, h: 1080 },
    compositions: [], // {id,name,cols,rows,tileW,tileH,x,y}
    selectedId: null,
    scale: 1
  };

  // ---------- Helpers DOM ----------
  const $ = (id) => document.getElementById(id);
  const preset = $('preset'), canvasW=$('canvasW'), canvasH=$('canvasH');
  const apply=$('apply'), fit=$('fit'), zoom1=$('zoom1');
  const name=$('name'), cols=$('cols'), rows=$('rows'), tileW=$('tileW'), tileH=$('tileH'), posX=$('posX'), posY=$('posY');
  const add=$('add'), update=$('update');
  const list=$('list'), msg=$('message'), canvasInfo=$('canvasInfo');
  const viewport=$('viewport'), screenWrap=$('screenWrap'), screen=$('screen');
  const saveBtn=$('save'), loadBtn=$('load'), clearBtn=$('clear');

  // ---------- Init canvas ----------
  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = w+"px";
    screen.style.height = h+"px";
    canvasInfo.textContent = `${w}×${h}px`;
    fitToViewport();
  }
  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `scale(${state.scale})`;
  }
  function zoom100(){ state.scale = 1; screenWrap.style.transform = `scale(1)`; }

  // ---------- Utils ----------
  const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
  const bbox = (c) => ({ x:c.x, y:c.y, w:c.cols*c.tileW, h:c.rows*c.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} });
  const clampToCanvas = (b) => b.x>=10 && b.y>=10 && b.x2<=10+state.canvas.w && b.y2<=10+state.canvas.h;
  function overlaps(a,b){ return !(a.x2<=b.x||a.x>=b.x2||a.y2<=b.y||a.y>=b.y2); }
  function collidesAny(id, B){ return state.compositions.some(c => c.id!==id && overlaps(B, bbox(c))); }

  function rightmost(){
    if (state.compositions.length===0) return null;
    let rm = state.compositions[0], m=bbox(rm).x2;
    for (const c of state.compositions){ const b=bbox(c); if (b.x2>m){ m=b.x2; rm=c; } }
    return bbox(rm);
  }

  // ---------- Render ----------
  function renderAll(){
    for (const el of [...screen.querySelectorAll('.comp')]) el.remove();
    for (const c of state.compositions) renderComp(c);
    refreshList();
  }

  function renderComp(c){
    const b = bbox(c);
    const el = document.createElement('div');
    el.className = 'comp' + (state.selectedId===c.id?' selected':'');
    el.style.left = b.x + 'px';
    el.style.top  = b.y + 'px';
    el.style.width  = b.w + 'px';
    el.style.height = b.h + 'px';
    el.dataset.id = c.id;

    // griglia interna per tile
    el.style.backgroundImage = `
      linear-gradient(to right, #1e3f3f 1px, transparent 1px),
      linear-gradient(to bottom, #1e3f3f 1px, transparent 1px)`;
    el.style.backgroundSize = `${c.tileW}px ${c.tileH}px, ${c.tileW}px ${c.tileH}px`;

    const info = document.createElement('div');
    info.className = 'info';
    info.textContent = `${b.w}×${b.h}px • (${c.x-10},${c.y-10})`;
    el.appendChild(info);

    const name = document.createElement('div');
    name.className = 'name';
    const fs = Math.max(16, Math.min(96, Math.floor(Math.min(b.w,b.h)*0.22)));
    name.style.fontSize = fs + 'px';
    name.style.top = `calc(50% - ${fs/2}px)`;
    name.textContent = c.name;
    el.appendChild(name);

    // === Drag & drop (mouse + touch) ===
    el.addEventListener('mousedown', (e)=> startDrag(e, c.id, el));
    el.addEventListener('touchstart', (e)=> startDrag(e, c.id, el), { passive:false });

    el.addEventListener('click', ()=> select(c.id));
    screen.appendChild(el);
  }

  function refreshList(){
    list.innerHTML = '';
    for (const c of state.compositions){
      const li = document.createElement('li');
      const left = document.createElement('div');
      const b = bbox(c);
      left.innerHTML = `<div style="font-weight:700; cursor:pointer">${c.name}</div>
        <div style="color:#9cb3c9; font-size:12px">${c.cols}×${c.rows} @ ${c.tileW}×${c.tileH}px — ${b.w}×${b.h}px — pos (${c.x-10},${c.y-10})</div>`;
      left.firstChild.onclick = ()=> select(c.id);
      const right = document.createElement('div');
      const dup = document.createElement('button'); dup.textContent='Duplica'; dup.className='secondary'; dup.onclick=()=> duplicate(c.id);
      const del = document.createElement('button'); del.textContent='Elimina'; del.className='warn'; del.onclick=()=> remove(c.id);
      right.append(dup, del);
      li.append(left, right);
      if (state.selectedId===c.id) li.style.outline='2px solid #3aa';
      list.append(li);
    }
  }

  // ---------- Drag&Drop: stessa logica del test (senza PointerEvents) ----------
  let dragData = null; // { id, el, offsetX, offsetY }

  function getEventPos(e){ if(e.touches&&e.touches[0]) e=e.touches[0]; return {x:e.clientX,y:e.clientY}; }

  function startDrag(e, id, el){
    e.preventDefault();
    select(id);
    const comp = state.compositions.find(x=>x.id===id);
    if(!comp) return;

    const pos = getEventPos(e);
    const rect = screen.getBoundingClientRect();
    const sx = (pos.x - rect.left) / state.scale; // coord nel sistema di screenWrap
    const sy = (pos.y - rect.top)  / state.scale;

    dragData = { id, el, offsetX: sx - comp.x, offsetY: sy - comp.y };
    el.classList.add('dragging');

    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchmove', onDragMove, { passive:false });
    document.addEventListener('touchend', endDrag);
  }

  function onDragMove(e){
    if(!dragData) return;
    e.preventDefault();
    const comp = state.compositions.find(x=>x.id===dragData.id);
    if(!comp) return;

    const pos = getEventPos(e);
    const rect = screen.getBoundingClientRect();
    let nx = (pos.x - rect.left)/state.scale - dragData.offsetX;
    let ny = (pos.y - rect.top) /state.scale - dragData.offsetY;

    const w = comp.cols*comp.tileW, h = comp.rows*comp.tileH;
    nx = Math.max(10, Math.min(10 + state.canvas.w - w, nx));
    ny = Math.max(10, Math.min(10 + state.canvas.h - h, ny));

    comp.x = nx; comp.y = ny;
    // Aggiorna SOLO il DOM del selezionato (no renderAll qui!)
    dragData.el.style.left = nx + 'px';
    dragData.el.style.top  = ny + 'px';
    const info = dragData.el.querySelector('.info');
    if (info) info.textContent = `${w}×${h}px • (${nx-10},${ny-10})`;
  }

  function endDrag(){
    if(!dragData) return;
    const el = dragData.el;
    dragData = null;
    el?.classList.remove('dragging');
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('touchend', endDrag);
    // ridisegno lista/selezioni ma NON tocco le posizioni appena messe
    refreshList();
  }

  // ---------- CRUD composizioni ----------
  function select(id){
    state.selectedId = id;
    const c = state.compositions.find(x=>x.id===id);
    if (c){
      name.value=c.name; rows.value=c.rows; cols.value=c.cols; tileW.value=c.tileW; tileH.value=c.tileH;
      posX.value=c.x-10; posY.value=c.y-10;
    }
    // highlight senza distruggere gli handlers: rendo/aggiorno tutto una volta
    renderAll();
  }
  function addComp(){
    const r=+rows.value, c=+cols.value, tw=+tileW.value, th=+tileH.value; const nm=(name.value||'Composizione').trim();
    if (!r||!c||!tw||!th) { msg.textContent='❌ R,C,tileW,tileH richiesti'; return; }
    const w=c*tw, h=r*th;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10+(+posX.value||0), y:10+(+posY.value||0) };
    let B = { x:pt.x, y:pt.y, w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(B) || collidesAny('new', B)){
      // se occupato, metti dove c'è spazio
      for (let y=10; y<=10+state.canvas.h-h; y++){
        for (let x=10; x<=10+state.canvas.w-w; x++){
          const T={x,y,w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h}};
          if (!collidesAny('new',T)) { B.x=x; B.y=y; x=Infinity; y=Infinity; }
        }
      }
    }
    const comp = { id:uid(), name:nm, cols:c, rows:r, tileW:tw, tileH:th, x:B.x, y:B.y };
    state.compositions.push(comp);
    state.selectedId = comp.id;
    renderAll();
    msg.textContent = `✅ Aggiunta ${comp.name}`;
  }
  function updateComp(){
    const id = state.selectedId; if (!id){ msg.textContent='Seleziona una composizione.'; return; }
    const c = state.compositions.find(x=>x.id===id);
    const nv = {
      name:(name.value||c.name).trim(),
      cols:+cols.value||c.cols,
      rows:+rows.value||c.rows,
      tileW:+tileW.value||c.tileW,
      tileH:+tileH.value||c.tileH,
      x:10 + (+posX.value||0),
      y:10 + (+posY.value||0)
    };
    const b = { x:nv.x, y:nv.y, w:nv.cols*nv.tileW, h:nv.rows*nv.tileH, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    if (!clampToCanvas(b) || collidesAny(id,b)) { msg.textContent='❌ Sovrapposizione o fuori canvas'; return; }
    Object.assign(c, nv);
    renderAll(); msg.textContent='✅ Aggiornata';
  }
  function duplicate(id){
    const src = state.compositions.find(x=>x.id===id);
    const w=src.cols*src.tileW, h=src.rows*src.tileH;
    const right = rightmost();
    let pt = right ? { x:right.x2+0, y:right.y } : { x:10, y:10 };
    let B = { x:pt.x, y:pt.y, w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h} };
    for (let tries=0; tries<2 && (!clampToCanvas(B) || collidesAny('new',B)); tries++){
      for (let y=10; y<=10+state.canvas.h-h; y++){
        for (let x=10; x<=10+state.canvas.w-w; x++){
          const T={x,y,w,h, get x2(){return this.x+this.w}, get y2(){return this.y+this.h}};
          if (!collidesAny('new',T)) { B.x=x; B.y=y; x=Infinity; y=Infinity; }
        }
      }
    }
    const nc = { ...src, id:uid(), name:src.name+' Copy', x:B.x, y:B.y };
    state.compositions.push(nc); state.selectedId=nc.id; renderAll();
  }
  function remove(id){ state.compositions = state.compositions.filter(x=>x.id!==id); if (state.selectedId===id) state.selectedId=null; renderAll(); }

  // ---------- Persistenza ----------
  saveBtn.onclick = () => { localStorage.setItem('ledwall.vanilla.project', JSON.stringify(state)); msg.textContent='💾 Salvato'; };
  loadBtn.onclick = () => {
    const raw = localStorage.getItem('ledwall.vanilla.project');
    if (!raw) { msg.textContent='Nessun salvataggio.'; return; }
    const data = JSON.parse(raw);
    Object.assign(state, data);
    applyCanvasSize(state.canvas.w, state.canvas.h);
    renderAll(); msg.textContent='✅ Caricato';
  };
  clearBtn.onclick = () => { state.compositions=[]; state.selectedId=null; renderAll(); msg.textContent='✅ Nuovo'; };

  // ---------- Event wiring ----------
  preset.onchange = () => { if(!preset.value) return; const [w,h] = preset.value.split('x').map(Number); canvasW.value=w; canvasH.value=h; };
  apply.onclick = () => { const w=+canvasW.value||1920, h=+canvasH.value||1080; applyCanvasSize(w,h); };
  fit.onclick = fitToViewport; zoom1.onclick = zoom100;
  add.onclick = addComp; update.onclick = updateComp;

  // ---------- Autoscale su resize/orientation ----------
  new ResizeObserver(() => fitToViewport()).observe(viewport);
  window.addEventListener('orientationchange', () => setTimeout(fitToViewport, 0));

  // ---------- Boot ----------
  canvasW.value = state.canvas.w; canvasH.value = state.canvas.h;
  applyCanvasSize(state.canvas.w, state.canvas.h);
  renderAll();
})();
</script>
</body>
</html>
