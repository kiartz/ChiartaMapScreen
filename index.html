<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper ‚Äì Snap & Pixel-Perfect</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:420px; display:flex; flex-direction:column; gap:12px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }

    /* Viewport / Canvas */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action:none; }
    #screen {
      position:absolute; left:10px; top:10px; /* margine estetico nel viewport */
      background:#0c0d11;
      border:1px solid #1e2229;  /* bordo reale su tutti i lati */
      box-sizing:content-box;     /* il bordo resta esterno alle dimensioni interne */
      touch-action:none; -webkit-user-select:none; user-select:none; overflow:hidden;
    }
    /* Griglia 100px */
    #screen::before { content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px; }

    /* Composizioni (rettangoli) */
    .comp {
      position:absolute; z-index:2; box-sizing:border-box;
      background:rgba(69,184,255,0.10);
      cursor:grab; touch-action:none; user-select:none;
      display:flex; align-items:center; justify-content:center; text-align:center; flex-direction:column;
      /* BORDO INTERNO 3px, sempre e ovunque */
      box-shadow: inset 0 0 0 3px var(--acc);
      /* Griglia interna (tile) ‚Äì aggiornata via JS */
      background-image:
        linear-gradient(to right, rgba(69,184,255,0.30) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(69,184,255,0.30) 1px, transparent 1px);
      background-size:128px 128px, 128px 128px;
      padding: 4px 8px;
    }
    .comp.selected { box-shadow: inset 0 0 0 3px #7fd0ff; }

    /* Testo principale auto-fit (font-size gestito da JS) */
    .comp .name,
    .comp .size {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.1;
      pointer-events: none;
    }
    .comp .name { font-weight:800; color:#eef6ff; text-shadow:0 1px 2px #000; }
    .comp .size { color:#d6e8ff; text-shadow:0 1px 2px #000; margin-top:4px; }

    /* Etichette offset (TL e BR) */
    .comp .offset,
    .comp .offsetBR {
      position:absolute; font-weight:600;
      color:#e9f6ff; text-shadow:0 1px 2px #000;
      background:rgba(10,15,20,0.55);
      border:1px solid rgba(127,208,255,0.35);
      border-radius:6px; padding:3px 6px;
      max-width:55%;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      line-height:1; pointer-events:none;
    }
    .comp .offset  { top:3px;    left:3px; }
    .comp .offsetBR{ bottom:3px; right:3px; }

    label{display:block;font-size:12px;color:#cfd3d7;margin:0 0 4px}
    input,button{border-radius:8px;border:1px solid var(--border);background:#0f1115;color:var(--ink);padding:8px}
    input[type=number]{width:100%}
    button{background:var(--acc);color:#001018;font-weight:700;cursor:pointer}
    button.secondary{ background:#0f1115; color:var(--ink) }
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}

    /* Toolbar sopra il canvas */
    #toolbar { display:flex; gap:8px; margin-bottom:6px; align-items:center; }
    #toolbar button { background:none; border:1px solid #444; cursor:pointer; color:var(--ink); font-size:16px; padding:4px 6px; border-radius:6px; }
    #toolbar button:hover { background:rgba(255,255,255,0.08); }
    #toolbar .spacer { margin-left:auto; color:#a0a6ad; font-size:12px; }

    /* Recap list */
    #recap { max-height:320px; overflow:auto; border:1px dashed var(--border); border-radius:10px; padding:8px; }
    .recap-item { display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:6px 8px; border-radius:8px; }
    .recap-item:hover { background:#101318; }
    .recap-item.selected { outline:1px solid #3578ff; background:#0d1320; }
    .pill { background:#0f1115; border:1px solid #2b2f36; border-radius:999px; padding:3px 8px; font-size:12px; color:#cfd3d7; }
    .editable { border-bottom:1px dashed #3a8fff; cursor:text; }
    .sep { color:#5f6772; }
  </style>
</head>
<body>
  <header>
    <div style="font-weight:800">LEDWall Mapper ‚Äì Snap & Pixel-Perfect</div>
  </header>

  <main>
    <section id="left">
      <div class="panel">
        <div style="font-weight:700; margin-bottom:8px">Canvas</div>
        <div class="grid2">
          <div>
            <label for="canvasW">Larghezza (px)</label>
            <input id="canvasW" type="number" min="1" step="1" value="1920">
          </div>
          <div>
            <label for="canvasH">Altezza (px)</label>
            <input id="canvasH" type="number" min="1" step="1" value="1080">
          </div>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="applyCanvas" style="flex:1">Applica</button>
          <button id="fit" class="secondary" style="flex:1">Fit</button>
        </div>
        <div style="margin-top:8px;font-size:12px;color:#a0a6ad">Canvas attuale: <span id="canvasInfo">‚Äì</span></div>
      </div>

      <div class="panel">
        <div style="font-weight:700; margin-bottom:8px">Nuova composizione</div>
        <div>
          <label for="compName">Nome</label>
          <input id="compName" type="text" placeholder="Ledwall Main">
        </div>

        <div class="grid2" style="margin-top:8px">
          <div>
            <label for="cols">Colonne (mattonelle)</label>
            <input id="cols" type="number" min="1" step="1" value="8">
          </div>
          <div>
            <label for="rows">Righe (mattonelle)</label>
            <input id="rows" type="number" min="1" step="1" value="4">
          </div>
          <div>
            <label for="tileW">Tile W (px)</label>
            <input id="tileW" type="number" min="1" step="1" value="128">
          </div>
          <div>
            <label for="tileH">Tile H (px)</label>
            <input id="tileH" type="number" min="1" step="1" value="128">
          </div>
        </div>

        <!-- Offset iniziale -->
        <div class="grid2" style="margin-top:8px">
          <div>
            <label for="startX">Offset X (px)</label>
            <input id="startX" type="number" min="0" step="1" value="0">
          </div>
          <div>
            <label for="startY">Offset Y (px)</label>
            <input id="startY" type="number" min="0" step="1" value="0">
          </div>
        </div>

        <button id="addComp" style="margin-top:10px; width:100%">Aggiungi composizione</button>
      </div>

      <!-- RECAP LIST -->
      <div class="panel">
        <div style="font-weight:700; margin-bottom:8px">Composizioni (recap & modifica rapida)</div>
        <div id="recap"></div>
        <div style="margin-top:8px; font-size:12px; color:#a0a6ad">
          Clicca su qualsiasi valore per modificarlo. Invio per confermare.
        </div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div id="toolbar">
          <button id="renameBtn" title="Rinomina">‚úé</button>
          <button id="duplicateBtn" title="Duplica">‚ßâ</button>
          <button id="deleteBtn" title="Elimina">üóëÔ∏è</button>
          <div class="spacer">Canvas: <span id="canvasInfoTop">‚Äì</span></div>
        </div>
        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Modal rinomina -->
  <div id="renameModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="renameTitle" style="display:none;">
    <div class="dialog">
      <h3 id="renameTitle">Rinomina composizione</h3>
      <label for="renameInput">Nome</label>
      <input type="text" id="renameInput" autocomplete="off" />
      <div class="row" style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
        <button id="renameCancel" class="secondary">Annulla</button>
        <button id="renameSave">Salva</button>
      </div>
    </div>
  </div>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">
      Drag fluido (mouse+touch) ancorato al punto di presa ‚Ä¢ Snap morbido ‚Ä¢ Bordi interni da 3px pixel-perfect ‚Ä¢ Auto-fit testo ‚Ä¢ Offset TL e BR dinamici ‚Ä¢ Offset iniziale a mano ‚Ä¢ Recap modificabile.
    </div>
  </footer>

<script>
(() => {
  // Stato
  const state = {
    canvas: { w:1920, h:1080 },
    scale: 1,
    counter: 0,
    selected: null,
  };
  const SNAP_THRESHOLD = 12; // px mondo
  const MIN_OFFSET_FONT = 10; // soglia sotto cui l'offset si nasconde

  // DOM refs
  const viewport = document.getElementById('viewport');
  const screenWrap = document.getElementById('screenWrap');
  const screen = document.getElementById('screen');
  const canvasInfo = document.getElementById('canvasInfo');
  const canvasInfoTop = document.getElementById('canvasInfoTop');
  const applyCanvasBtn = document.getElementById('applyCanvas');
  const fitBtn = document.getElementById('fit');
  const canvasWInput = document.getElementById('canvasW');
  const canvasHInput = document.getElementById('canvasH');

  const compNameInput = document.getElementById('compName');
  const colsInput = document.getElementById('cols');
  const rowsInput = document.getElementById('rows');
  const tileWInput = document.getElementById('tileW');
  const tileHInput = document.getElementById('tileH');
  const startXInput = document.getElementById('startX');
  const startYInput = document.getElementById('startY');
  const addCompBtn = document.getElementById('addComp');

  const renameBtn = document.getElementById('renameBtn');
  const dupBtn = document.getElementById('duplicateBtn');
  const delBtn = document.getElementById('deleteBtn');
  const renameModal = document.getElementById('renameModal');
  const renameInput = document.getElementById('renameInput');
  const renameSave = document.getElementById('renameSave');
  const renameCancel = document.getElementById('renameCancel');

  const recap = document.getElementById('recap');

  // Utilities
  const toInt = (v, fb) => { const n = parseInt(String(v).replace(/[^0-9]/g,''),10); return Number.isFinite(n) ? n : fb; };
  const clampPos = (n)=> Math.max(0, n);
  const px = (n)=> Math.round(n) + 'px';
  const uid = ()=> Math.random().toString(36).slice(2) + Date.now().toString(36);

  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = px(w); screen.style.height = px(h);
    canvasInfo.textContent = `${w}√ó${h}px`;
    canvasInfoTop.textContent = `${w}√ó${h}px`;
    fitToViewport();
  }

  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `translateZ(0) scale(${state.scale})`;
  }

  function selectComp(el){
    if (state.selected && state.selected !== el){ state.selected.classList.remove('selected'); }
    state.selected = el;
    if (state.selected) state.selected.classList.add('selected');
    updateToolbarState();
    highlightRecapSelection();
  }
  function clearSelection(){ if(state.selected){ state.selected.classList.remove('selected'); state.selected=null; updateToolbarState(); highlightRecapSelection(); } }
  function updateToolbarState(){ const has = !!state.selected; dupBtn.disabled = !has; delBtn.disabled = !has; renameBtn.disabled = !has; }

  // ---- Auto-fit testo (nome, dimensioni, offset) ----
  const _measureCanvas = document.createElement('canvas');
  const _mctx = _measureCanvas.getContext('2d');
  const FONT_FAMILY = "system-ui, -apple-system, Segoe UI, Roboto, sans-serif";

  function textWidthPx(text, weight, sizePx) {
    _mctx.font = `${weight} ${sizePx}px ${FONT_FAMILY}`;
    return Math.ceil(_mctx.measureText(text).width);
  }
  function maxFontThatFits(text, weight, maxWidth, maxHeight, minPx=8, maxPx=160) {
    let lo = minPx, hi = maxPx, best = minPx;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const w = textWidthPx(text, weight, mid);
      const h = Math.ceil(mid * 1.1);
      if (w <= maxWidth && h <= maxHeight) { best = mid; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    return best;
  }

  function fitLabels(el) {
    const nameEl = el.querySelector('.name');
    const sizeEl = el.querySelector('.size');
    const offTL  = el.querySelector('.offset');
    const offBR  = el.querySelector('.offsetBR');

    if (nameEl && sizeEl) {
      const padH = 16, padV = 8;
      const innerW = el.clientWidth - padH;
      const innerH = el.clientHeight - padV;

      const nameMaxH = Math.max(10, Math.floor(innerH * 0.70));
      const sizeMaxH = Math.max(10, Math.floor(innerH * 0.25));

      const namePx = maxFontThatFits(nameEl.textContent||"", "800", innerW, nameMaxH, 8, 160);
      const sizePx = maxFontThatFits(sizeEl.textContent||"", "400", innerW, sizeMaxH, 8, 64);

      nameEl.style.fontSize = namePx + "px";
      sizeEl.style.fontSize = sizePx + "px";
    }

    const fitCorner = (elCorner)=>{
      if (!elCorner) return;
      const text = elCorner.textContent || "";
      const maxWidth  = Math.max(20, Math.floor(el.clientWidth * 0.55) - 8);
      const maxHeight = Math.max(10, Math.floor(el.clientHeight * 0.18) - 6);
      const f = maxFontThatFits(text, "600", maxWidth, maxHeight, 9, 22);
      elCorner.style.display = (f < MIN_OFFSET_FONT) ? 'none' : 'inline-block';
      if (f >= MIN_OFFSET_FONT) elCorner.style.fontSize = f + 'px';
    };
    fitCorner(offTL); fitCorner(offBR);
  }

  // ---- Offset labels ----
  function updateOffsetLabels(el){
    const offTL = el.querySelector('.offset');
    const offBR = el.querySelector('.offsetBR');
    const x = Math.round(parseFloat(el.style.left) || 0);
    const y = Math.round(parseFloat(el.style.top)  || 0);
    const w = el.offsetWidth;
    const h = el.offsetHeight;
    if (offTL) offTL.textContent = `(${x}, ${y})`;
    if (offBR) offBR.textContent = `(${x + w - 1}, ${y + h - 1})`;
    fitLabels(el);
    refreshRecap(); // tiene la lista in sync in tempo reale
  }

  // Drag + Snap
  function makeDraggable(el){
    let drag = null;
    const getPos = (e)=>{ if(e.touches&&e.touches[0]) e=e.touches[0]; return {x:e.clientX,y:e.clientY}; };

    const start = (e)=>{
      e.preventDefault(); e.stopPropagation();
      selectComp(el);
      const p = getPos(e);
      const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const curLeft = parseFloat(el.style.left) || 0;
      const curTop  = parseFloat(el.style.top)  || 0;
      drag = { offsetX: pointerWorldX - curLeft, offsetY: pointerWorldY - curTop };
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', end);
      window.addEventListener('touchmove', move, { passive:false });
      window.addEventListener('touchend', end);
    };

    const move = (e)=>{
      if(!drag) return; e.preventDefault(); e.stopPropagation();
      const p = getPos(e); const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const w = el.offsetWidth, h = el.offsetHeight;

      let nx = pointerWorldX - drag.offsetX;
      let ny = pointerWorldY - drag.offsetY;

      // SNAP ad altri rettangoli
      const comps = [...document.querySelectorAll('.comp')].filter(n=>n!==el);
      let bestDX = Infinity, bestNX = nx; let bestDY = Infinity, bestNY = ny;
      const L = nx, R = nx + w, CX = nx + w/2;
      const T = ny, B = ny + h, CY = ny + h/2;

      const snapEdgeX = (nx, targetX, edge)=>{
        if (edge==='L') return targetX;
        if (edge==='R') return targetX - w;
        if (edge==='C') return Math.round(targetX - w/2);
        return nx;
      };
      const snapEdgeY = (ny, targetY, edge)=>{
        if (edge==='T') return targetY;
        if (edge==='B') return targetY - h;
        if (edge==='C') return Math.round(targetY - h/2);
        return ny;
      };

      for (const n of comps){
        const left = parseFloat(n.style.left)||0;
        const top  = parseFloat(n.style.top)||0;
        const nw = n.offsetWidth, nh = n.offsetHeight;
        const targetsX = [left, left+nw, left+nw/2];
        const targetsY = [top, top+nh, top+nh/2];
        for (const tx of targetsX){
          const cands = [ ['L', Math.abs(L-tx)], ['R', Math.abs(R-tx)], ['C', Math.abs(CX-tx)] ];
          for (const [edge,dist] of cands){ if (dist <= SNAP_THRESHOLD && dist < bestDX){ bestDX = dist; bestNX = snapEdgeX(nx, tx, edge); } }
        }
        for (const ty of targetsY){
          const cands = [ ['T', Math.abs(T-ty)], ['B', Math.abs(B-ty)], ['C', Math.abs(CY-ty)] ];
          for (const [edge,dist] of cands){ if (dist <= SNAP_THRESHOLD && dist < bestDY){ bestDY = dist; bestNY = snapEdgeY(ny, ty, edge); } }
        }
      }
      nx = bestNX; ny = bestNY;

      // SNAP alla griglia (tile)
      const tileW = parseInt(el.dataset.tileW || '1', 10) || 1;
      const tileH = parseInt(el.dataset.tileH || '1', 10) || 1;
      const nearestGX = Math.round(nx / tileW) * tileW;
      const nearestGY = Math.round(ny / tileH) * tileH;
      if (Math.abs(nx - nearestGX) <= SNAP_THRESHOLD) nx = nearestGX;
      if (Math.abs(ny - nearestGY) <= SNAP_THRESHOLD) ny = nearestGY;

      // clamp entro canvas
      nx = Math.max(0, Math.min(state.canvas.w - w, nx));
      ny = Math.max(0, Math.min(state.canvas.h - h, ny));

      nx = Math.round(nx); ny = Math.round(ny);
      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';
      updateOffsetLabels(el);
    };

    const end = ()=>{
      drag = null;
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', end);
      window.removeEventListener('touchmove', move);
      window.removeEventListener('touchend', end);
    };

    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start, { passive:false });
    el.addEventListener('click', (e)=>{ e.stopPropagation(); selectComp(el); });
  }

  // Aggiunta composizione
  function addComposition(){
    const name = (compNameInput.value || `Composizione ${state.counter+1}`).trim();
    const cols = Math.max(1, toInt(colsInput.value, 1));
    const rows = Math.max(1, toInt(rowsInput.value, 1));
    const tileW = Math.max(1, toInt(tileWInput.value, 1));
    const tileH = Math.max(1, toInt(tileHInput.value, 1));

    const w = cols * tileW;
    const h = rows * tileH;

    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = uid();
    el.style.width = px(w);
    el.style.height = px(h);
    el.style.backgroundSize = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px`;
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    // Label offset TL e BR
    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);

    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = name; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}√ó${h}px`; el.appendChild(sizeEl);

    // offset iniziale
    let nx = clampPos(toInt(startXInput.value, 0));
    let ny = clampPos(toInt(startYInput.value, 0));
    nx = Math.min(state.canvas.w - w, nx);
    ny = Math.min(state.canvas.h - h, ny);
    el.style.left = px(nx);
    el.style.top  = px(ny);

    screen.appendChild(el);
    makeDraggable(el);
    updateOffsetLabels(el);
    selectComp(el);
    state.counter++;
  }

  // Duplica / Elimina (toolbar)
  dupBtn.addEventListener('click', ()=>{
    const src = state.selected; if(!src) return;
    const w = src.offsetWidth, h = src.offsetHeight;
    const tileW = parseInt(src.dataset.tileW||'1',10)||1;
    const tileH = parseInt(src.dataset.tileH||'1',10)||1;

    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = uid();
    el.style.width = px(w);
    el.style.height = px(h);
    el.style.backgroundSize = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px`;
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);

    const nameSrc = src.querySelector('.name')?.textContent || `Composizione`;
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = nameSrc + ' Copy'; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}√ó${h}px`; el.appendChild(sizeEl);

    let nx = (parseFloat(src.style.left)||0) + 24;
    let ny = (parseFloat(src.style.top)||0) + 24;
    nx = Math.min(state.canvas.w - w, Math.max(0, nx));
    ny = Math.min(state.canvas.h - h, Math.max(0, ny));
    el.style.left = px(nx);
    el.style.top  = px(ny);

    screen.appendChild(el);
    makeDraggable(el);
    updateOffsetLabels(el);
    selectComp(el);
  });

  delBtn.addEventListener('click', ()=>{ if(!state.selected) return; const next = state.selected.nextElementSibling || state.selected.previousElementSibling; state.selected.remove(); state.selected = null; updateToolbarState(); refreshRecap(); if(next){ selectComp(next); } });

  // Rinomina (modal)
  function openRename(){ if(!state.selected) return; const cName = state.selected.querySelector('.name'); renameInput.value = cName?.textContent || ""; renameModal.style.display='flex'; renameInput.focus(); renameInput.setSelectionRange(0, renameInput.value.length); }
  function closeRename(){ renameModal.style.display='none'; }
  function saveRename(){ if(!state.selected) return; const v = (renameInput.value||"").trim(); if(v){ state.selected.querySelector('.name').textContent = v; fitLabels(state.selected); refreshRecap(); } closeRename(); }
  renameBtn.addEventListener('click', openRename);
  renameCancel.addEventListener('click', closeRename);
  renameSave.addEventListener('click', saveRename);
  renameModal.addEventListener('click', (e)=>{ if(e.target===renameModal) closeRename(); });
  renameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') saveRename(); if(e.key==='Escape') closeRename(); });

  // CANVAS UI
  applyCanvasBtn.addEventListener('click', ()=>{
    const w = Math.max(1, toInt(canvasWInput.value, state.canvas.w));
    const h = Math.max(1, toInt(canvasHInput.value, state.canvas.h));
    applyCanvasSize(w,h);
  });
  fitBtn.addEventListener('click', fitToViewport);
  addCompBtn.addEventListener('click', addComposition);
  screen.addEventListener('click', ()=>{ clearSelection(); });

  new ResizeObserver(()=>fitToViewport()).observe(viewport);
  window.addEventListener('orientationchange', ()=>setTimeout(fitToViewport,0));

  // ===== Recap list =====
  function getAllComps(){ return [...document.querySelectorAll('.comp')]; }

  function compData(el){
    const w = el.offsetWidth, h = el.offsetHeight;
    const tileW = parseInt(el.dataset.tileW||'1',10)||1;
    const tileH = parseInt(el.dataset.tileH||'1',10)||1;
    const cols = Math.round(w / tileW);
    const rows = Math.round(h / tileH);
    const x = Math.round(parseFloat(el.style.left)||0);
    const y = Math.round(parseFloat(el.style.top) ||0);
    const name = el.querySelector('.name')?.textContent || '';
    const id = el.dataset.id || '';
    return {id, name, cols, rows, tileW, tileH, w, h, x, y};
  }

  function refreshRecap(){
    const items = getAllComps().map(compData);
    recap.innerHTML = '';
    for (const it of items){
      const row = document.createElement('div');
      row.className = 'recap-item';
      row.dataset.id = it.id;
      if (state.selected && state.selected.dataset.id === it.id) row.classList.add('selected');

      const makeEditable = (label, value, field, widthCh=6)=>{
        const span = document.createElement('span');
        span.className = 'pill editable';
        span.style.minWidth = `${widthCh}ch`;
        span.contentEditable = 'true';
        span.spellcheck = false;
        span.dataset.field = field;
        span.textContent = String(value);
        span.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); span.blur(); } });
        span.addEventListener('focus', ()=> selectById(it.id));
        span.addEventListener('blur', ()=> applyEdit(it.id, field, span.textContent));
        const wrap = document.createElement('span');
        wrap.className = 'pill';
        wrap.style.background = 'transparent';
        wrap.style.border = 'none';
        wrap.style.padding = '0';
        const lab = document.createElement('span');
        lab.className = 'pill';
        lab.textContent = label;
        lab.style.marginRight = '4px';
        const group = document.createElement('span');
        group.appendChild(lab);
        group.appendChild(span);
        group.style.display = 'inline-flex';
        group.style.alignItems = 'center';
        group.style.gap = '6px';
        return group;
      };

      const sep = ()=>{ const s=document.createElement('span'); s.className='sep'; s.textContent='‚Ä¢'; return s; }

      // Nome
      const nameEl = makeEditable('Nome', it.name, 'name', Math.max(6, it.name.length));
      // Tiles (cols x rows)
      const colsEl = makeEditable('Cols', it.cols, 'cols', 4);
      const rowsEl = makeEditable('Rows', it.rows, 'rows', 4);
      // Tile size
      const twEl = makeEditable('TileW', it.tileW, 'tileW', 5);
      const thEl = makeEditable('TileH', it.tileH, 'tileH', 5);
      // Offset
      const xEl = makeEditable('X', it.x, 'x', 4);
      const yEl = makeEditable('Y', it.y, 'y', 4);
      // Risoluzione totale (solo display)
      const tot = document.createElement('span');
      tot.className = 'pill';
      tot.textContent = `Tot: ${it.w}√ó${it.h}px`;

      // Compose row
      row.appendChild(nameEl);
      row.appendChild(sep());
      const groupTiles = document.createElement('span');
      groupTiles.className='pill';
      groupTiles.style.gap='6px'; groupTiles.style.display='inline-flex'; groupTiles.style.alignItems='center';
      groupTiles.style.background='transparent'; groupTiles.style.border='none'; groupTiles.style.padding='0';
      groupTiles.append('Tiles:', colsEl.querySelector('.editable'), document.createTextNode('√ó'), rowsEl.querySelector('.editable'));
      row.appendChild(groupTiles);

      row.appendChild(sep());
      const groupPix = document.createElement('span');
      groupPix.className='pill';
      groupPix.style.gap='6px'; groupPix.style.display='inline-flex'; groupPix.style.alignItems='center';
      groupPix.style.background='transparent'; groupPix.style.border='none'; groupPix.style.padding='0';
      groupPix.append('Tile(px):', twEl.querySelector('.editable'), document.createTextNode('√ó'), thEl.querySelector('.editable'));
      row.appendChild(groupPix);

      row.appendChild(sep());
      row.appendChild(tot);

      row.appendChild(sep());
      const groupOff = document.createElement('span');
      groupOff.className='pill';
      groupOff.style.gap='6px'; groupOff.style.display='inline-flex'; groupOff.style.alignItems='center';
      groupOff.style.background='transparent'; groupOff.style.border='none'; groupOff.style.padding='0';
      groupOff.append('Offset:', xEl.querySelector('.editable'), document.createTextNode(','), yEl.querySelector('.editable'));
      row.appendChild(groupOff);

      // Selezione al click
      row.addEventListener('click', (e)=> { if(!(e.target instanceof HTMLElement && e.target.isContentEditable)){ selectById(it.id); } });

      recap.appendChild(row);
    }
  }

  function selectById(id){
    const el = getAllComps().find(n=> n.dataset.id===id);
    if (el) selectComp(el);
    highlightRecapSelection();
  }

  function highlightRecapSelection(){
    const idSel = state.selected?.dataset.id;
    recap.querySelectorAll('.recap-item').forEach(r=>{
      r.classList.toggle('selected', r.dataset.id===idSel);
    });
  }

  // Applicazione modifiche dal recap
  function applyEdit(id, field, rawValue){
    const el = getAllComps().find(n=> n.dataset.id===id);
    if (!el) return;
    const val = toInt(rawValue, NaN);

    // Dati attuali
    let w = el.offsetWidth, h = el.offsetHeight;
    let tileW = parseInt(el.dataset.tileW||'1',10)||1;
    let tileH = parseInt(el.dataset.tileH||'1',10)||1;
    let cols = Math.round(w / tileW);
    let rows = Math.round(h / tileH);
    let x = Math.round(parseFloat(el.style.left)||0);
    let y = Math.round(parseFloat(el.style.top) ||0);

    const nameNode = el.querySelector('.name');

    if (field === 'name'){
      const text = (rawValue||'').trim();
      if (text) { nameNode.textContent = text; fitLabels(el); }
      refreshRecap();
      return;
    }

    if (!Number.isFinite(val)) { refreshRecap(); return; }

    switch(field){
      case 'cols': cols = Math.max(1, val); w = cols * tileW; break;
      case 'rows': rows = Math.max(1, val); h = rows * tileH; break;
      case 'tileW': tileW = Math.max(1, val); el.dataset.tileW = String(tileW); w = cols * tileW; break;
      case 'tileH': tileH = Math.max(1, val); el.dataset.tileH = String(tileH); h = rows * tileH; break;
      case 'x': x = clampPos(val); break;
      case 'y': y = clampPos(val); break;
    }

    // Clamp a canvas
    w = Math.max(1, Math.min(state.canvas.w, w));
    h = Math.max(1, Math.min(state.canvas.h, h));
    x = Math.min(state.canvas.w - w, Math.max(0, x));
    y = Math.min(state.canvas.h - h, Math.max(0, y));

    // Applica dimensioni e griglia interna
    el.style.width = px(w);
    el.style.height = px(h);
    el.style.backgroundSize = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px`;
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    // Aggiorna testi interni
    const sizeEl = el.querySelector('.size');
    sizeEl.textContent = `${w}√ó${h}px`;

    // Posizione (se modificata)
    el.style.left = px(x);
    el.style.top  = px(y);

    // Re-fit testi e offset
    updateOffsetLabels(el);

    // Mantiene selezione e recap sync
    selectComp(el);
    refreshRecap();
  }

  // Boot
  applyCanvasSize(parseInt(canvasWInput.value,10)||1920, parseInt(canvasHInput.value,10)||1080);
  addComposition(); // facoltativo: crea un esempio iniziale
  refreshRecap();
  updateToolbarState();
})();
</script>
</body>
</html>
