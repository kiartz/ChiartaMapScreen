<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper ‚Äì Snap & Pixel-Perfect + Palette</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:420px; display:flex; flex-direction:column; gap:10px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }

    /* Viewport / Canvas */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action:none; }
    #screen {
      position:absolute; left:10px; top:10px;
      background:#0c0d11; border:1px solid #1e2229; box-sizing:content-box;
      touch-action:none; -webkit-user-select:none; user-select:none; overflow:hidden;
    }
    #screen::before { content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px; }

    /* Composizioni */
    .comp {
      position:absolute; z-index:2; box-sizing:border-box;
      cursor:grab; touch-action:none; user-select:none;
      display:flex; align-items:center; justify-content:center; text-align:center; flex-direction:column;
      /* Bordo interno */
      box-shadow: inset 0 0 0 3px var(--acc);
      /* La griglia + pattern vengono impostati via JS con background-image (3 layer) */
      padding: 4px 8px;
    }
    .comp.selected { box-shadow: inset 0 0 0 3px #7fd0ff; }
    .comp .name, .comp .size {
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.1; pointer-events: none;
      color:#eef6ff; text-shadow:0 1px 2px #000;
    }
    .comp .size { color:#d6e8ff; margin-top:4px; }

    /* Offset TL e BR */
    .comp .offset, .comp .offsetBR {
      position:absolute; font-weight:600;
      color:#e9f6ff; text-shadow:0 1px 2px #000;
      background:rgba(10,15,20,0.55);
      border:1px solid rgba(127,208,255,0.35);
      border-radius:6px; padding:3px 6px;
      max-width:55%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      line-height:1; pointer-events:none;
    }
    .comp .offset  { top:3px;    left:3px; }
    .comp .offsetBR{ bottom:3px; right:3px; }

    /* Form & pills */
    label{display:block;font-size:11px;color:#cfd3d7;margin:0 0 3px}
    input,button,select{border-radius:8px;border:1px solid var(--border);background:#0f1115;color:var(--ink);padding:7px 8px;font-size:13px}
    input[type=text], select{width:100%}
    input[type=color]{padding:0;border-radius:6px;border:1px solid #2b2f36;width:34px;height:28px;background:#0f1115;cursor:pointer}
    button{background:var(--acc);color:#001018;font-weight:700;cursor:pointer}
    button.secondary{ background:#0f1115; color:var(--ink) }

    .grid6{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
    .gridCol{display:grid;grid-template-columns:1fr 1fr;gap:6px}
    .colorsRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

    /* Toolbar sopra il canvas */
    #toolbar { display:flex; gap:6px; margin-bottom:6px; align-items:center; flex-wrap:wrap; }
    #toolbar button.icon { background:none; border:1px solid #444; color:var(--ink); font-size:16px; padding:4px 6px; border-radius:6px; }
    #toolbar button.icon:hover { background:rgba(255,255,255,0.08); }
    #toolbar .spacer { flex:1; }

    /* Inline canvas size editor (compatto) */
    .canvas-size { display:flex; align-items:center; gap:6px; background:#0f1115; border:1px solid #2b2f36; padding:4px 6px; border-radius:8px; }
    .canvas-size input { width:84px; padding:5px 6px; font-size:12px; }
    .canvas-size .x { color:#88909a; font-size:12px; }
    .canvas-size .btns { display:flex; gap:4px; }
    .canvas-size .btns button { background:none; border:1px solid #444; padding:4px 6px; font-size:12px; border-radius:6px; color:#cfe6ff; }
    .canvas-size .btns button:hover { background:rgba(255,255,255,0.08); }

    /* Project bar */
    #projectBar { display:flex; gap:6px; align-items:center; }
    #projectBar input { padding:6px 8px; font-size:13px; }
    #projectBar button, #projectBar label.btn {
      background:none; border:1px solid #444; border-radius:8px; padding:6px 8px; font-size:13px; cursor:pointer; color:var(--ink);
    }
    #projectBar button:hover, #projectBar label.btn:hover { background:rgba(255,255,255,0.08); }
    #projectBar .grow { flex:1; min-width:0; }

    /* Recap */
    #recap { max-height:280px; overflow:auto; border:1px dashed var(--border); border-radius:10px; padding:8px; }
    .recap-item { display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:6px 8px; border-radius:8px; }
    .recap-item:hover { background:#101318; }
    .recap-item.selected { outline:1px solid #3578ff; background:#0d1320; }
    .pill { background:#0f1115; border:1px solid #2b2f36; border-radius:999px; padding:3px 8px; font-size:12px; color:#cfd3d7; }
    .editable { border-bottom:1px dashed #3a8fff; cursor:text; }
    .sep { color:#5f6772; }

    /* Modal semplice */
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:50}
    .modal .dialog{background:#151519;border:1px solid #2b2f36;border-radius:12px;padding:16px;min-width:280px;max-width:90vw}
  </style>
</head>
<body>
  <header>
    <div style="font-weight:800">LEDWall Mapper ‚Äì Snap & Pixel-Perfect</div>
  </header>

  <main>
    <section id="left">
      <!-- Project Bar -->
      <div class="panel" style="padding:10px">
        <div id="projectBar">
          <input id="projectName" type="text" class="grow" placeholder="Nome progetto (es. MainStage)" />
          <button id="saveBtn" title="Salva (JSON)">üíæ</button>
          <label for="loadFile" class="btn" title="Carica (JSON)">üìÇ</label>
          <input id="loadFile" type="file" accept=".json,application/json" style="display:none">
        </div>
        <div style="margin-top:6px"><small>I campi accettano formule: <code>*2</code>, <code>+64</code>, <code>128*3</code>‚Ä¶</small></div>
      </div>

      <!-- Nuova composizione (compatto) + Palette -->
      <div class="panel" style="padding:10px">
        <div style="font-weight:700; margin-bottom:6px">Nuova composizione</div>
        <div>
          <label for="compName">Nome</label>
          <input id="compName" type="text" placeholder="Ledwall Main">
        </div>
        <div class="grid6" style="margin-top:6px">
          <div><label for="cols">Cols</label><input id="cols" type="text" value="8"  placeholder="8, *2"></div>
          <div><label for="rows">Rows</label><input id="rows" type="text" value="4"  placeholder="4, +1"></div>
          <div><label for="tileW">TileW</label><input id="tileW" type="text" value="128" placeholder="128, *2"></div>
          <div><label for="tileH">TileH</label><input id="tileH" type="text" value="128" placeholder="128, -16"></div>
          <div><label for="startX">X</label><input id="startX" type="text" value="0" placeholder="0, +128"></div>
          <div><label for="startY">Y</label><input id="startY" type="text" value="0" placeholder="0, +128"></div>
        </div>

        <div style="margin-top:10px">
          <div class="gridCol">
            <div>
              <label for="colorCount">Colori (1‚Äì4)</label>
              <select id="colorCount">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
            </div>
            <div>
              <label>Palette</label>
              <div class="colorsRow">
                <input type="color" id="col1" value="#3b82f6" title="Colore 1">
                <input type="color" id="col2" value="#10b981" title="Colore 2">
                <input type="color" id="col3" value="#f97316" title="Colore 3" style="display:none">
                <input type="color" id="col4" value="#ec4899" title="Colore 4" style="display:none">
              </div>
            </div>
          </div>
          <small style="color:#9aa4af">Seleziona quante tinte usare. Le caselle mostrano il picker di colore.</small>
        </div>

        <button id="addComp" style="margin-top:10px; width:100%">Aggiungi</button>
      </div>

      <!-- Recap -->
      <div class="panel" style="padding:10px">
        <div style="font-weight:700; margin-bottom:6px">Composizioni</div>
        <div id="recap"></div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div id="toolbar">
          <button id="renameBtn" class="icon" title="Rinomina">‚úé</button>
          <button id="duplicateBtn" class="icon" title="Duplica">‚ßâ</button>
          <button id="deleteBtn" class="icon" title="Elimina">üóëÔ∏è</button>
          <div class="spacer"></div>
          <div class="canvas-size" title="Dimensione canvas (formule supportate)">
            <input id="canvasW" type="text" value="1920" placeholder="1920, +10, *2" aria-label="Canvas width">
            <span class="x">√ó</span>
            <input id="canvasH" type="text" value="1080" placeholder="1080, *2" aria-label="Canvas height">
            <div class="btns">
              <button id="applyCanvas" title="Applica">Applica</button>
              <button id="fit" title="Fit">Fit</button>
            </div>
          </div>
        </div>

        <div id="viewport">
          <div id="screenWrap">
            <div id="screen"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Modal rinomina -->
  <div id="renameModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="renameTitle" style="display:none;">
    <div class="dialog">
      <h3 id="renameTitle">Rinomina composizione</h3>
      <label for="renameInput">Nome</label>
      <input type="text" id="renameInput" autocomplete="off" />
      <div class="row" style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
        <button id="renameCancel" class="secondary">Annulla</button>
        <button id="renameSave">Salva</button>
      </div>
    </div>
  </div>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">
      Drag fluido ‚Ä¢ Snap morbido ‚Ä¢ Bordi interni 3px pixel-perfect ‚Ä¢ Auto-fit testo ‚Ä¢ Offset TL/BR ‚Ä¢ Recap modificabile ‚Ä¢ Calcoli inline ‚Ä¢ Salva/Carica JSON ‚Ä¢ Palette 1-4 colori a scacchiera.
    </div>
  </footer>

<script>
(()=> {
  // ===== Helpers: espressioni intere =====
  function evalIntExpression(expr, base) {
    if (typeof expr !== 'string') expr = String(expr ?? '');
    const s = expr.trim();
    if (!s) return NaN;
    const cleaned = s.replace(/[^0-9+\-*/().\s]/g, '');
    let finalExpr = cleaned;
    if (/^[+\-*/]/.test(cleaned)) finalExpr = `(${base}|0)${cleaned}`;
    let out = NaN;
    try { const f = new Function(`return (${finalExpr});`); const val = f(); if (Number.isFinite(val)) out = Math.round(val); }
    catch(_) { out = NaN; }
    return out;
  }
  const px = (n)=> Math.round(n) + 'px';
  const uid = ()=> Math.random().toString(36).slice(2) + Date.now().toString(36);

  // ===== Stato =====
  const state = { canvas: { w:1920, h:1080 }, scale: 1, selected: null,
    defaults: { colorCount:2, colors:['#3b82f6','#10b981','#f97316','#ec4899'] }
  };
  const SNAP_THRESHOLD = 12;
  const MIN_OFFSET_FONT = 10;

  // ===== DOM =====
  const viewport = document.getElementById('viewport');
  const screenWrap = document.getElementById('screenWrap');
  const screen = document.getElementById('screen');

  const projectNameInput = document.getElementById('projectName');
  const saveBtn = document.getElementById('saveBtn');
  const loadFile = document.getElementById('loadFile');

  const compNameInput = document.getElementById('compName');
  const colsInput = document.getElementById('cols');
  const rowsInput = document.getElementById('rows');
  const tileWInput = document.getElementById('tileW');
  const tileHInput = document.getElementById('tileH');
  const startXInput = document.getElementById('startX');
  const startYInput = document.getElementById('startY');
  const colorCountSel = document.getElementById('colorCount');
  const col1 = document.getElementById('col1');
  const col2 = document.getElementById('col2');
  const col3 = document.getElementById('col3');
  const col4 = document.getElementById('col4');
  const addCompBtn = document.getElementById('addComp');

  const renameBtn = document.getElementById('renameBtn');
  const dupBtn = document.getElementById('duplicateBtn');
  const delBtn = document.getElementById('deleteBtn');
  const renameModal = document.getElementById('renameModal');
  const renameInput = document.getElementById('renameInput');
  const renameSave = document.getElementById('renameSave');
  const renameCancel = document.getElementById('renameCancel');

  const canvasWInput = document.getElementById('canvasW');
  const canvasHInput = document.getElementById('canvasH');
  const applyCanvasBtn = document.getElementById('applyCanvas');
  const fitBtn = document.getElementById('fit');

  const recap = document.getElementById('recap');

  // ===== Canvas sizing =====
  function applyCanvasSize(w,h){
    state.canvas.w = w; state.canvas.h = h;
    screen.style.width = px(w); screen.style.height = px(h);
    fitToViewport();
    // Clamp e refresh offset
    document.querySelectorAll('.comp').forEach(el=>{
      let x = Math.round(parseFloat(el.style.left)||0);
      let y = Math.round(parseFloat(el.style.top)||0);
      const cw = el.offsetWidth, ch = el.offsetHeight;
      x = Math.max(0, Math.min(state.canvas.w - cw, x));
      y = Math.max(0, Math.min(state.canvas.h - ch, y));
      el.style.left = px(x); el.style.top = px(y);
      updateOffsetLabels(el);
    });
  }
  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / (state.canvas.w + 20);
    const sy = vh / (state.canvas.h + 20);
    state.scale = Math.min(sx, sy, 1);
    screenWrap.style.transform = `translateZ(0) scale(${state.scale})`;
  }

  function selectComp(el){
    if (state.selected && state.selected !== el){ state.selected.classList.remove('selected'); }
    state.selected = el;
    if (state.selected) {
      state.selected.classList.add('selected');
      // carica palette nel pannello
      colorCountSel.value = state.selected.dataset.colorCount || String(state.defaults.colorCount);
      const cols = getCompColors(state.selected);
      [col1,col2,col3,col4].forEach((inp, i)=> inp.value = cols[i] || state.defaults.colors[i]);
      updateColorPickersVisibility();
    }
    updateToolbarState();
    highlightRecapSelection();
  }
  function clearSelection(){ if(state.selected){ state.selected.classList.remove('selected'); state.selected=null; updateToolbarState(); highlightRecapSelection(); } }
  function updateToolbarState(){ const has = !!state.selected; dupBtn.disabled = !has; delBtn.disabled = !has; renameBtn.disabled = !has; }

  // ===== Auto-fit testo =====
  const _measureCanvas = document.createElement('canvas');
  const _mctx = _measureCanvas.getContext('2d');
  const FONT_FAMILY = "system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
  function textWidthPx(text, weight, sizePx) { _mctx.font = `${weight} ${sizePx}px ${FONT_FAMILY}`; return Math.ceil(_mctx.measureText(text).width); }
  function maxFontThatFits(text, weight, maxWidth, maxHeight, minPx=8, maxPx=160) {
    let lo=minPx, hi=maxPx, best=minPx;
    while (lo<=hi) { const mid=(lo+hi>>1); const w=textWidthPx(text,weight,mid), h=Math.ceil(mid*1.1);
      if (w<=maxWidth && h<=maxHeight) { best=mid; lo=mid+1; } else { hi=mid-1; } }
    return best;
  }
  function fitLabels(el) {
    const nameEl = el.querySelector('.name');
    const sizeEl = el.querySelector('.size');
    const offTL  = el.querySelector('.offset');
    const offBR  = el.querySelector('.offsetBR');

    if (nameEl && sizeEl) {
      const padH=16, padV=8, innerW=el.clientWidth - padH, innerH=el.clientHeight - padV;
      const namePx = maxFontThatFits(nameEl.textContent||"", "800", innerW, Math.max(10, Math.floor(innerH*0.70)), 8, 160);
      const sizePx = maxFontThatFits(sizeEl.textContent||"", "400", innerW, Math.max(10, Math.floor(innerH*0.25)), 8, 64);
      nameEl.style.fontSize = namePx + "px"; sizeEl.style.fontSize = sizePx + "px";
    }
    const fitCorner = (elCorner)=>{
      if (!elCorner) return;
      const maxWidth  = Math.max(20, Math.floor(el.clientWidth * 0.55) - 8);
      const maxHeight = Math.max(10, Math.floor(el.clientHeight * 0.18) - 6);
      const f = maxFontThatFits(elCorner.textContent||"", "600", maxWidth, maxHeight, 9, 22);
      elCorner.style.display = (f < MIN_OFFSET_FONT) ? 'none' : 'inline-block';
      if (f >= MIN_OFFSET_FONT) elCorner.style.fontSize = f + 'px';
    };
    fitCorner(offTL); fitCorner(offBR);
  }

  // ===== Offset labels =====
  function updateOffsetLabels(el){
    const offTL = el.querySelector('.offset');
    const offBR = el.querySelector('.offsetBR');
    const x = Math.round(parseFloat(el.style.left) || 0);
    const y = Math.round(parseFloat(el.style.top)  || 0);
    const w = el.offsetWidth;
    const h = el.offsetHeight;
    if (offTL) offTL.textContent = `(${x}, ${y})`;
    if (offBR) offBR.textContent = `(${x + w - 1}, ${y + h - 1})`;
    fitLabels(el);
    refreshRecap();
  }

  // ===== Pattern a scacchiera (1‚Äì4 colori) =====
  function getCompColors(el){
    const count = parseInt(el?.dataset.colorCount || state.defaults.colorCount, 10);
    const arr = [
      el?.dataset.c1 || state.defaults.colors[0],
      el?.dataset.c2 || state.defaults.colors[1],
      el?.dataset.c3 || state.defaults.colors[2],
      el?.dataset.c4 || state.defaults.colors[3],
    ];
    return arr.slice(0, Math.max(1, Math.min(4, count)));
  }

  function makePatternDataURL(colors, tileW, tileH){
    const n = Math.max(1, Math.min(4, colors.length));
    let cols = colors.slice(0,n);
    let pattCols = 1, pattRows = 1;

    if (n === 1) { pattCols=1; pattRows=1; }
    else if (n === 2) { pattCols=2; pattRows=2; /* c1 c2 / c2 c1 */ }
    else if (n === 3) { pattCols=3; pattRows=3; /* (i+j)%3 */ }
    else { pattCols=2; pattRows=2; /* c1 c2 / c3 c4 */ }

    const W = Math.max(1, tileW * pattCols);
    const H = Math.max(1, tileH * pattRows);

    const c = document.createElement('canvas');
    c.width = W; c.height = H;
    const ctx = c.getContext('2d');

    for (let r=0; r<pattRows; r++){
      for (let q=0; q<pattCols; q++){
        let color = cols[0];
        if (n===1){
          color = cols[0];
        } else if (n===2){
          // 2x2: [c1,c2; c2,c1]
          color = ( (r+q) % 2 === 0 ) ? cols[0] : cols[1];
        } else if (n===3){
          // 3x3: (i+j)%3
          color = cols[(r+q)%3];
        } else if (n===4){
          // 2x2: [c1,c2; c3,c4]
          if (r===0 && q===0) color = cols[0];
          else if (r===0 && q===1) color = cols[1];
          else if (r===1 && q===0) color = cols[2];
          else color = cols[3];
        }
        ctx.fillStyle = color;
        ctx.fillRect(q*tileW, r*tileH, tileW, tileH);
      }
    }
    return { url: c.toDataURL(), pattW: W, pattH: H };
  }

  function applyCompBackground(el){
    const tileW = parseInt(el.dataset.tileW||'1',10)||1;
    const tileH = parseInt(el.dataset.tileH||'1',10)||1;
    const colors = getCompColors(el);
    const { url, pattW, pattH } = makePatternDataURL(colors, tileW, tileH);

    const gridX = 'linear-gradient(to right, rgba(69,184,255,0.30) 1px, transparent 1px)';
    const gridY = 'linear-gradient(to bottom, rgba(69,184,255,0.30) 1px, transparent 1px)';
    el.style.backgroundImage = `${gridX}, ${gridY}, url("${url}")`;
    el.style.backgroundSize  = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px, ${pattW}px ${pattH}px`;
    el.style.backgroundPosition = `0 0, 0 0, 0 0`;
    el.style.backgroundRepeat = `repeat, repeat, repeat`;
  }

  // ===== Drag + Snap =====
  function makeDraggable(el){
    let drag = null;
    const getPos = (e)=>{ if(e.touches&&e.touches[0]) e=e.touches[0]; return {x:e.clientX,y:e.clientY}; };

    const start = (e)=>{
      e.preventDefault(); e.stopPropagation();
      selectComp(el);
      const p = getPos(e);
      const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const curLeft = parseFloat(el.style.left) || 0;
      const curTop  = parseFloat(el.style.top)  || 0;
      drag = { offsetX: pointerWorldX - curLeft, offsetY: pointerWorldY - curTop };
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', end);
      window.addEventListener('touchmove', move, { passive:false });
      window.addEventListener('touchend', end);
    };

    const move = (e)=>{
      if(!drag) return; e.preventDefault(); e.stopPropagation();
      const p = getPos(e); const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top)  / state.scale;
      const w = el.offsetWidth, h = el.offsetHeight;

      let nx = pointerWorldX - drag.offsetX;
      let ny = pointerWorldY - drag.offsetY;

      // SNAP ad altri rettangoli
      const comps = [...document.querySelectorAll('.comp')].filter(n=>n!==el);
      let bestDX = Infinity, bestNX = nx; let bestDY = Infinity, bestNY = ny;
      const L = nx, R = nx + w, CX = nx + w/2;
      const T = ny, B = ny + h, CY = ny + h/2;

      const snapEdgeX = (nx, targetX, edge)=>{
        if (edge==='L') return targetX;
        if (edge==='R') return targetX - w;
        if (edge==='C') return Math.round(targetX - w/2);
        return nx;
      };
      const snapEdgeY = (ny, targetY, edge)=>{
        if (edge==='T') return targetY;
        if (edge==='B') return targetY - h;
        if (edge==='C') return Math.round(targetY - h/2);
        return ny;
      };

      for (const n of comps){
        const left = parseFloat(n.style.left)||0;
        const top  = parseFloat(n.style.top)||0;
        const nw = n.offsetWidth, nh = n.offsetHeight;
        const targetsX = [left, left+nw, left+nw/2];
        const targetsY = [top, top+nh, top+nh/2];
        for (const tx of targetsX){
          const cands = [ ['L', Math.abs(L-tx)], ['R', Math.abs(R-tx)], ['C', Math.abs(CX-tx)] ];
          for (const [edge,dist] of cands){ if (dist <= SNAP_THRESHOLD && dist < bestDX){ bestDX = dist; bestNX = snapEdgeX(nx, tx, edge); } }
        }
        for (const ty of targetsY){
          const cands = [ ['T', Math.abs(T-ty)], ['B', Math.abs(B-ty)], ['C', Math.abs(CY-ty)] ];
          for (const [edge,dist] of cands){ if (dist <= SNAP_THRESHOLD && dist < bestDY){ bestDY = dist; bestNY = snapEdgeY(ny, ty, edge); } }
        }
      }
      nx = bestNX; ny = bestNY;

      // SNAP alla griglia (tile)
      const tileW = parseInt(el.dataset.tileW || '1', 10) || 1;
      const tileH = parseInt(el.dataset.tileH || '1', 10) || 1;
      const nearestGX = Math.round(nx / tileW) * tileW;
      const nearestGY = Math.round(ny / tileH) * tileH;
      if (Math.abs(nx - nearestGX) <= SNAP_THRESHOLD) nx = nearestGX;
      if (Math.abs(ny - nearestGY) <= SNAP_THRESHOLD) ny = nearestGY;

      // clamp entro canvas
      nx = Math.max(0, Math.min(state.canvas.w - w, nx));
      ny = Math.max(0, Math.min(state.canvas.h - h, ny));

      nx = Math.round(nx); ny = Math.round(ny);
      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';
      updateOffsetLabels(el);
    };

    const end = ()=>{
      drag = null;
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', end);
      window.removeEventListener('touchmove', move);
      window.removeEventListener('touchend', end);
    };

    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start, { passive:false });
    el.addEventListener('click', (e)=>{ e.stopPropagation(); selectComp(el); });
  }

  // ===== Creazione composizione =====
  function addComposition(){
    const name = (compNameInput.value || `Composizione`).trim();
    const baseCols=8, baseRows=4, baseTW=128, baseTH=128, baseSX=0, baseSY=0;
    const cols  = Math.max(1, evalIntExpression(colsInput.value,  baseCols) ?? baseCols);
    const rows  = Math.max(1, evalIntExpression(rowsInput.value,  baseRows) ?? baseRows);
    const tileW = Math.max(1, evalIntExpression(tileWInput.value, baseTW)   ?? baseTW);
    const tileH = Math.max(1, evalIntExpression(tileHInput.value, baseTH)   ?? baseTH);
    let   nx    = Math.max(0, evalIntExpression(startXInput.value, baseSX)  ?? baseSX);
    let   ny    = Math.max(0, evalIntExpression(startYInput.value, baseSY)  ?? baseSY);

    const w = cols * tileW;
    const h = rows * tileH;

    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = uid();
    el.style.width = px(w);
    el.style.height = px(h);

    // Palette (default o pannello corrente)
    const count = parseInt(colorCountSel.value, 10);
    const colors = [
      col1.value || state.defaults.colors[0],
      col2.value || state.defaults.colors[1],
      col3.value || state.defaults.colors[2],
      col4.value || state.defaults.colors[3],
    ];
    el.dataset.colorCount = String(count);
    el.dataset.c1 = colors[0]; el.dataset.c2 = colors[1]; el.dataset.c3 = colors[2]; el.dataset.c4 = colors[3];

    el.style.backgroundSize = `${tileW}px ${tileH}px, ${tileW}px ${tileH}px`; // completato da applyCompBackground
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = name; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}√ó${h}px`; el.appendChild(sizeEl);

    nx = Math.min(state.canvas.w - w, nx);
    ny = Math.min(state.canvas.h - h, ny);
    el.style.left = px(nx);
    el.style.top  = px(ny);

    screen.appendChild(el);
    makeDraggable(el);
    applyCompBackground(el);
    updateOffsetLabels(el);
    selectComp(el);
  }

  // ===== Toolbar / Rinomina / Duplica / Elimina =====
  const renameOpen = ()=>{ if(!state.selected) return; const cName = state.selected.querySelector('.name'); renameInput.value = cName?.textContent || ""; document.getElementById('renameModal').style.display='flex'; renameInput.focus(); renameInput.setSelectionRange(0, renameInput.value.length); };
  const renameClose= ()=>{ document.getElementById('renameModal').style.display='none'; };
  const renameSaveFn = ()=>{ if(!state.selected) return; const v=(renameInput.value||"").trim(); if(v){ state.selected.querySelector('.name').textContent=v; fitLabels(state.selected); refreshRecap(); } renameClose(); };

  document.getElementById('renameBtn').addEventListener('click', renameOpen);
  renameCancel.addEventListener('click', renameClose);
  renameSave.addEventListener('click', renameSaveFn);
  document.getElementById('renameModal').addEventListener('click', (e)=>{ if(e.target.id==='renameModal') renameClose(); });
  renameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') renameSaveFn(); if(e.key==='Escape') renameClose(); });

  document.getElementById('duplicateBtn').addEventListener('click', ()=>{
    const src = state.selected; if(!src) return;
    const w = src.offsetWidth, h = src.offsetHeight;
    const tileW = parseInt(src.dataset.tileW||'1',10)||1;
    const tileH = parseInt(src.dataset.tileH||'1',10)||1;

    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = uid();
    el.style.width = px(w);
    el.style.height = px(h);
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    // Copia palette
    el.dataset.colorCount = src.dataset.colorCount || '2';
    el.dataset.c1 = src.dataset.c1 || '#3b82f6';
    el.dataset.c2 = src.dataset.c2 || '#10b981';
    el.dataset.c3 = src.dataset.c3 || '#f97316';
    el.dataset.c4 = src.dataset.c4 || '#ec4899';

    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
    const nameEl = document.createElement('div'); nameEl.className = 'name';
    nameEl.textContent = (src.querySelector('.name')?.textContent || `Composizione`) + ' Copy';
    el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}√ó${h}px`; el.appendChild(sizeEl);

    let nx = (parseFloat(src.style.left)||0) + 24;
    let ny = (parseFloat(src.style.top)||0) + 24;
    nx = Math.min(state.canvas.w - w, Math.max(0, nx));
    ny = Math.min(state.canvas.h - h, Math.max(0, ny));
    el.style.left = px(nx); el.style.top = px(ny);

    screen.appendChild(el);
    makeDraggable(el);
    applyCompBackground(el);
    updateOffsetLabels(el);
    selectComp(el);
  });

  document.getElementById('deleteBtn').addEventListener('click', ()=>{
    if(!state.selected) return;
    const next = state.selected.nextElementSibling || state.selected.previousElementSibling;
    state.selected.remove();
    state.selected=null; updateToolbarState(); refreshRecap();
    if(next){ selectComp(next); }
  });

  // ===== Canvas controls =====
  applyCanvasBtn.addEventListener('click', ()=>{
    const newW = Math.max(1, evalIntExpression(canvasWInput.value, state.canvas.w) || state.canvas.w);
    const newH = Math.max(1, evalIntExpression(canvasHInput.value, state.canvas.h) || state.canvas.h);
    applyCanvasSize(newW, newH);
    canvasWInput.value = String(newW);
    canvasHInput.value = String(newH);
  });
  fitBtn.addEventListener('click', fitToViewport);

  // ===== Pannello Palette (visibilit√† e change) =====
  function updateColorPickersVisibility(){
    const n = parseInt(colorCountSel.value, 10);
    col1.style.display = n>=1 ? '' : 'none';
    col2.style.display = n>=2 ? '' : 'none';
    col3.style.display = n>=3 ? '' : 'none';
    col4.style.display = n>=4 ? '' : 'none';
  }
  colorCountSel.addEventListener('change', ()=>{
    updateColorPickersVisibility();
    if (state.selected){
      state.selected.dataset.colorCount = colorCountSel.value;
      applyCompBackground(state.selected);
    } else {
      state.defaults.colorCount = parseInt(colorCountSel.value,10);
    }
  });
  [col1,col2,col3,col4].forEach((inp, i)=>{
    inp.addEventListener('input', ()=>{
      if (state.selected){
        state.selected.dataset['c'+(i+1)] = inp.value;
        applyCompBackground(state.selected);
      } else {
        state.defaults.colors[i] = inp.value;
      }
    });
  });
  updateColorPickersVisibility();

  // ===== Aggiungi composizione =====
  addCompBtn.addEventListener('click', addComposition);
  screen.addEventListener('click', ()=>{ clearSelection(); });

  new ResizeObserver(()=>fitToViewport()).observe(viewport);
  window.addEventListener('orientationchange', ()=>setTimeout(fitToViewport,0));

  // ===== Recap =====
  function getAllComps(){ return [...document.querySelectorAll('.comp')]; }
  function compData(el){
    const w = el.offsetWidth, h = el.offsetHeight;
    const tileW = parseInt(el.dataset.tileW||'1',10)||1;
    const tileH = parseInt(el.dataset.tileH||'1',10)||1;
    const cols = Math.round(w / tileW);
    const rows = Math.round(h / tileH);
    const x = Math.round(parseFloat(el.style.left)||0);
    const y = Math.round(parseFloat(el.style.top) ||0);
    const name = el.querySelector('.name')?.textContent || '';
    const id = el.dataset.id || '';
    return {id, name, cols, rows, tileW, tileH, w, h, x, y};
  }

  function refreshRecap(){
    const items = getAllComps().map(compData);
    recap.innerHTML = '';
    for (const it of items){
      const row = document.createElement('div');
      row.className = 'recap-item';
      row.dataset.id = it.id;
      if (state.selected && state.selected.dataset.id === it.id) row.classList.add('selected');

      const makeEditable = (label, value, field, widthCh=6)=>{
        const span = document.createElement('span');
        span.className = 'pill editable';
        span.style.minWidth = `${widthCh}ch`;
        span.contentEditable = 'true';
        span.spellcheck = false;
        span.dataset.field = field;
        span.dataset.base = String(value);
        span.textContent = String(value);
        span.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); span.blur(); } });
        span.addEventListener('focus', ()=> selectById(it.id));
        span.addEventListener('blur', ()=> applyEdit(it.id, field, span.textContent, Number(span.dataset.base)));
        const lab = document.createElement('span');
        lab.className = 'pill'; lab.textContent = label; lab.style.marginRight='4px';
        const group = document.createElement('span');
        group.style.display='inline-flex'; group.style.alignItems='center'; group.style.gap='6px';
        group.append(lab, span);
        return group;
      };

      const sep = ()=>{ const s=document.createElement('span'); s.className='sep'; s.textContent='‚Ä¢'; return s; }

      const nameEl = makeEditable('Nome', it.name, 'name', Math.max(6, it.name.length));
      const colsEl = makeEditable('Cols', it.cols, 'cols', 4);
      const rowsEl = makeEditable('Rows',  it.rows, 'rows', 4);
      const twEl   = makeEditable('TileW', it.tileW,'tileW', 5);
      const thEl   = makeEditable('TileH', it.tileH,'tileH', 5);
      const xEl    = makeEditable('X', it.x, 'x', 4);
      const yEl    = makeEditable('Y', it.y, 'y', 4);

      const tot = document.createElement('span'); tot.className='pill'; tot.textContent = `Tot: ${it.w}√ó${it.h}px`;

      row.append(nameEl, sep());
      const groupTiles = document.createElement('span'); groupTiles.className='pill'; groupTiles.style.gap='6px'; groupTiles.style.display='inline-flex'; groupTiles.style.alignItems='center'; groupTiles.style.background='transparent'; groupTiles.style.border='none'; groupTiles.style.padding='0';
      groupTiles.append('Tiles:', colsEl.querySelector('.editable'), document.createTextNode('√ó'), rowsEl.querySelector('.editable'));
      row.append(groupTiles, sep());
      const groupPix = document.createElement('span'); groupPix.className='pill'; groupPix.style.gap='6px'; groupPix.style.display='inline-flex'; groupPix.style.alignItems='center'; groupPix.style.background='transparent'; groupPix.style.border='none'; groupPix.style.padding='0';
      groupPix.append('Tile(px):', twEl.querySelector('.editable'), document.createTextNode('√ó'), thEl.querySelector('.editable'));
      row.append(groupPix, sep(), tot, sep());
      const groupOff = document.createElement('span'); groupOff.className='pill'; groupOff.style.gap='6px'; groupOff.style.display='inline-flex'; groupOff.style.alignItems='center'; groupOff.style.background='transparent'; groupOff.style.border='none'; groupOff.style.padding='0';
      groupOff.append('Offset:', xEl.querySelector('.editable'), document.createTextNode(','), yEl.querySelector('.editable'));
      row.append(groupOff);

      row.addEventListener('click', (e)=> { if(!(e.target instanceof HTMLElement && e.target.isContentEditable)){ selectById(it.id); } });
      recap.appendChild(row);
    }
  }

  function selectById(id){
    const el = getAllComps().find(n=> n.dataset.id===id);
    if (el) selectComp(el);
    highlightRecapSelection();
  }

  function highlightRecapSelection(){
    const idSel = state.selected?.dataset.id;
    recap.querySelectorAll('.recap-item').forEach(r=>{
      r.classList.toggle('selected', r.dataset.id===idSel);
    });
  }

  function applyEdit(id, field, rawValue, baseValue){
    const el = getAllComps().find(n=> n.dataset.id===id);
    if (!el) return;

    let w = el.offsetWidth, h = el.offsetHeight;
    let tileW = parseInt(el.dataset.tileW||'1',10)||1;
    let tileH = parseInt(el.dataset.tileH||'1',10)||1;
    let cols = Math.round(w / tileW);
    let rows = Math.round(h / tileH);
    let x = Math.round(parseFloat(el.style.left)||0);
    let y = Math.round(parseFloat(el.style.top) ||0);

    if (field === 'name'){
      const text = (rawValue||'').trim();
      if (text) { el.querySelector('.name').textContent = text; fitLabels(el); }
      refreshRecap(); return;
    }

    const v = evalIntExpression(rawValue, baseValue);
    if (!Number.isFinite(v)) { refreshRecap(); return; }

    switch(field){
      case 'cols': cols = Math.max(1, v); w = cols * tileW; break;
      case 'rows': rows = Math.max(1, v); h = rows * tileH; break;
      case 'tileW': tileW = Math.max(1, v); el.dataset.tileW = String(tileW); w = cols * tileW; break;
      case 'tileH': tileH = Math.max(1, v); el.dataset.tileH = String(tileH); h = rows * tileH; break;
      case 'x': x = Math.max(0, v); break;
      case 'y': y = Math.max(0, v); break;
    }

    // Clamp a canvas
    w = Math.max(1, Math.min(state.canvas.w, w));
    h = Math.max(1, Math.min(state.canvas.h, h));
    x = Math.min(state.canvas.w - w, Math.max(0, x));
    y = Math.min(state.canvas.h - h, Math.max(0, y));

    el.style.width = px(w);
    el.style.height = px(h);
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);

    el.querySelector('.size').textContent = `${w}√ó${h}px`;
    el.style.left = px(x);
    el.style.top  = px(y);
    applyCompBackground(el);
    updateOffsetLabels(el);

    selectComp(el);
    refreshRecap();
  }

  // ===== Salva / Carica =====
  function getAllComps(){ return [...document.querySelectorAll('.comp')]; }
  function collectProject(){
    const comps = getAllComps().map(el=>{
      const w = el.offsetWidth, h = el.offsetHeight;
      const tileW = parseInt(el.dataset.tileW||'1',10)||1;
      const tileH = parseInt(el.dataset.tileH||'1',10)||1;
      const cols = Math.round(w / tileW);
      const rows = Math.round(h / tileH);
      const x = Math.round(parseFloat(el.style.left)||0);
      const y = Math.round(parseFloat(el.style.top) ||0);
      const name = el.querySelector('.name')?.textContent || '';
      return {
        id: el.dataset.id || uid(),
        name, cols, rows, tileW, tileH, x, y,
        colorCount: parseInt(el.dataset.colorCount||'2',10),
        colors: [el.dataset.c1, el.dataset.c2, el.dataset.c3, el.dataset.c4]
      };
    });

    return {
      version: 2,
      name: (projectNameInput.value||'Progetto').trim(),
      canvas: { w: state.canvas.w, h: state.canvas.h },
      compositions: comps,
      defaults: state.defaults
    };
  }
  function saveProject(){
    const data = collectProject();
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const safeName = (data.name||'progetto').replace(/[^a-z0-9_\-]+/gi,'_').toLowerCase();
    a.href = url; a.download = `${safeName}.json`; a.click();
    URL.revokeObjectURL(url);
  }
  function clearCanvas(){ getAllComps().forEach(el=> el.remove()); state.selected = null; updateToolbarState(); refreshRecap(); }
  function createCompFromData(c){
    const w = c.cols * c.tileW, h = c.rows * c.tileH;
    const el = document.createElement('div');
    el.className = 'comp'; el.dataset.id = c.id || uid();
    el.style.width = px(w); el.style.height = px(h);
    el.dataset.tileW = String(c.tileW); el.dataset.tileH = String(c.tileH);

    // palette
    el.dataset.colorCount = String(c.colorCount ?? 2);
    const arr = c.colors || [];
    el.dataset.c1 = arr[0] || state.defaults.colors[0];
    el.dataset.c2 = arr[1] || state.defaults.colors[1];
    el.dataset.c3 = arr[2] || state.defaults.colors[2];
    el.dataset.c4 = arr[3] || state.defaults.colors[3];

    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = c.name || 'Composizione'; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}√ó${h}px`; el.appendChild(sizeEl);
    let nx = Math.max(0, Math.min(state.canvas.w - w, Math.round(c.x||0)));
    let ny = Math.max(0, Math.min(state.canvas.h - h, Math.round(c.y||0)));
    el.style.left = px(nx); el.style.top  = px(ny);
    screen.appendChild(el); makeDraggable(el); applyCompBackground(el); updateOffsetLabels(el);
  }
  function loadProjectFromObject(obj){
    if (!obj || typeof obj !== 'object') return;
    const w = Math.max(1, parseInt(obj.canvas?.w,10) || 1920);
    const h = Math.max(1, parseInt(obj.canvas?.h,10) || 1080);
    applyCanvasSize(w,h); canvasWInput.value = String(w); canvasHInput.value = String(h);
    projectNameInput.value = obj.name || '';

    // defaults palette
    if (obj.defaults){
      state.defaults.colorCount = Math.max(1, Math.min(4, parseInt(obj.defaults.colorCount||2,10)));
      if (Array.isArray(obj.defaults.colors)){
        for (let i=0;i<4;i++) if (obj.defaults.colors[i]) state.defaults.colors[i] = obj.defaults.colors[i];
      }
      colorCountSel.value = String(state.defaults.colorCount);
      [col1,col2,col3,col4].forEach((inp,i)=> inp.value = state.defaults.colors[i]);
      updateColorPickersVisibility();
    }

    clearCanvas();
    (obj.compositions||[]).forEach(createCompFromData);
    refreshRecap();
  }
  saveBtn.addEventListener('click', saveProject);
  loadFile.addEventListener('change', (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      try { const obj = JSON.parse(String(ev.target?.result||'{}')); loadProjectFromObject(obj); }
      catch(err){ alert('File non valido.'); }
    };
    reader.readAsText(file); e.target.value = '';
  });

  // ===== Boot =====
  applyCanvasSize(1920, 1080);
  // demo iniziale
  addComposition();
  refreshRecap();
  updateToolbarState();
})();
</script>
</body>
</html>
