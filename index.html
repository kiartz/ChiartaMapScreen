<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEDWall Mapper – Multi-Screen, Snap & Pixel-Perfect</title>
  <style>
    :root { --bg:#0e0e10; --panel:#151519; --border:#272a2f; --ink:#e8eaed; --muted:#a0a6ad; --acc:#45b8ff; --warn:#ffb454; --tileLine:#9fd7ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    header, footer { padding:8px 12px; background:#0b0c0f; position:sticky; top:0; z-index:5; border-bottom:1px solid var(--border); }
    main { display:flex; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #left { width:420px; display:flex; flex-direction:column; gap:10px; }
    #work { flex:1; display:flex; flex-direction:column; gap:10px; }

    /* Viewport / Canvas */
    #viewport { position:relative; flex:1; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#0a0b0f; cursor: grab; }
    #viewport:active { cursor: grabbing; }
    #screenWrap { position:absolute; left:0; top:0; transform-origin: top left; touch-action:none; }
    #screen {
      position:absolute; left:10px; top:10px;
      background:#0c0d11; border:1px solid #1e2229; box-sizing:content-box;
      touch-action:none; -webkit-user-select:none; user-select:none; overflow:hidden;
    }
    #screen::before { content:""; position:absolute; inset:0; pointer-events:none;
      background-image:
        linear-gradient(to right, #181c24 1px, transparent 1px),
        linear-gradient(to bottom, #181c24 1px, transparent 1px);
      background-size:100px 100px, 100px 100px; }
    
    #selectionBox {
      position: absolute;
      border: 1px solid var(--acc);
      background: rgba(69, 184, 255, 0.2);
      z-index: 10;
      pointer-events: none;
      display: none;
    }

    /* Composizioni */
    .comp {
      position:absolute; z-index:2; box-sizing:border-box;
      cursor:pointer; touch-action:none; user-select:none;
      display:flex; align-items:center; justify-content:center; text-align:center; flex-direction:column;
      box-shadow: inset 0 0 0 3px var(--acc);
      padding: 4px 8px;
      background-repeat: repeat;
      background-position: 0 0;
    }
    .comp.selected { 
      box-shadow: inset 0 0 0 5px #ffffff; 
    }
    .comp .name {
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.1; pointer-events: none;
      color:#eef6ff; text-shadow:0 1px 2px #000;
      position: relative;
      font-weight: bold;
    }
    .comp .size {
      color:#d6e8ff;
      position: absolute;
      left: 50%;
      font-weight: bold;
    }

    /* Offset TL e BR */
    .comp .offset, .comp .offsetBR {
      position:absolute; font-weight:600;
      color:#e9f6ff; text-shadow:0 1px 2px #000;
      background:rgba(10,15,20,0.55);
      border:1px solid rgba(127,208,255,0.35);
      border-radius:6px; padding:3px 6px;
      max-width:55%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      line-height:1; pointer-events:none;
    }
    .comp .offset  { top:32px; left:3px; }
    .comp .offsetBR{ bottom:3px; right:3px; }

    /* Form & pills */
    label{display:block;font-size:11px;color:#cfd3d7;margin:0 0 3px}
    input,button,select{border-radius:8px;border:1px solid var(--border);background:#0f1115;color:var(--ink);padding:7px 8px;font-size:13px}
    input[type=text], select{width:100%}
    button{background:var(--acc);color:#001018;font-weight:700;cursor:pointer}
    button.secondary{ background:#0f1115; color:var(--ink) }

    .grid6{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}

    /* Toolbar sopra il canvas */
    #toolbar { display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap; }
    #toolbar button.icon { background:none; border:1px solid #444; color:var(--ink); font-size:16px; padding:4px 6px; border-radius:6px; }
    #toolbar button.icon:hover { background:rgba(255,255,255,0.08); }
    #toolbar .spacer { flex:1; }
    .divider { width:1px; height:26px; background:#2b2f36; }

    /* Stili vari */
    .canvas-size, .screen-ctrl, .palette { display:flex; align-items:center; gap:6px; background:#0f1115; border:1px solid #2b2f36; padding:4px 8px; border-radius:8px; }
    .canvas-size input { width:84px; padding:5px 6px; font-size:12px; }
    .canvas-size .x { color:#88909a; font-size:12px; }
    .canvas-size .btns { display:flex; gap:4px; }
    .canvas-size .btns button { background:none; border:1px solid #444; padding:4px 6px; font-size:12px; border-radius:6px; color:#cfe6ff; }
    .canvas-size .btns button:hover { background:rgba(255,255,255,0.08); }
    .screen-ctrl select, .palette select { width:auto; padding:4px 6px; font-size:12px; }
    .swatch { width:24px; height:22px; border-radius:6px; border:1px solid #2b2f36; overflow:hidden; position:relative; }
    .swatch input[type=color]{ position:absolute; inset:0; opacity:0; cursor:pointer; }
    .swatch .preview{ position:absolute; inset:0; border-radius:6px; }

    .zoom-controls { display:flex; align-items:center; gap:4px; }
    .zoom-controls button { padding: 4px 8px; font-size: 14px; font-weight: bold; }

    /* Stili per i Popup della Toolbar */
    .popup-container { position: relative; }
    .popup {
      display: none;
      position: absolute;
      top: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      z-index: 10;
    }
    .popup.visible { display: block; }

    #fontSizePopup { width: 250px; }
    #fontSizePopup .slider-row { display:flex; align-items:center; gap:8px; margin-bottom: 4px; }
    #fontSizePopup .slider-row:last-child { margin-bottom: 0; }
    #fontSizePopup .slider-row > span:first-child { width: 32px; font-size: 11px; color: var(--muted); font-weight: 600; }
    
    .editable-value {
      font-size: 12px; color: var(--ink); min-width: 40px; text-align: right; cursor: text;
      border-bottom: 1px dashed transparent; padding: 2px 4px; border-radius: 4px;
    }
    .editable-value:hover { border-bottom-color: var(--muted); }
    .editable-value:focus { outline: 1px solid var(--acc); background: #000; border-bottom-color: transparent; }

    /* Stili per il popup Visibilità */
    #visibilityPopup { width: 200px; }
    .visibility-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .visibility-row:last-child { margin-bottom: 0; }
    .visibility-row span { font-size: 13px; }
    .visibility-row button { font-size: 11px; padding: 3px 8px; background: #333; color: #ccc; font-weight: 600; border-color: #444; }
    .visibility-row button.active { background: var(--acc); color: #000; }

    /* Classi per nascondere gli elementi */
    body.hide-names .comp .name,
    body.hide-sizes .comp .size,
    body.hide-tile-labels .comp .tile-label {
      display: none;
    }
    body.hide-offset-tl .comp .offset,
    body.hide-offset-br .comp .offsetBR {
      display: none !important;
    }

    /* Stili Recap e Modal */
    #recap { max-height:280px; overflow:auto; border:1px dashed var(--border); border-radius:10px; padding:8px; scroll-behavior: smooth; }
    .recap-item { display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:6px 8px; border-radius:8px; }
    .recap-item:hover { background:#101318; }
    .recap-item.selected { outline:1px solid #3578ff; background:#0d1320; }
    .pill { background:#0f1115; border:1px solid #2b2f36; border-radius:999px; padding:3px 8px; font-size:12px; color:#cfd3d7; }
    .editable { border-bottom:1px dashed #3a8fff; cursor:text; }
    .sep { color:#5f6772; }
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:50}
    .modal .dialog{background:#151519;border:1px solid #2b2f36;border-radius:12px;padding:16px;min-width:280px;max-width:90vw}
  
    .tile-label{
      position:absolute;
      left:0; top:0; transform:translate(2px,2px);
      font-weight:700;
      font-size:12px;
      line-height:1;
      color:#ffffff;
      text-shadow:0 1px 2px rgba(0,0,0,.9);
      pointer-events:none;
      user-select:none;
      white-space:nowrap;
    }
    
    #version {
        position: fixed;
        bottom: 8px;
        left: 12px;
        font-size: 11px;
        color: var(--muted);
        opacity: 0.5;
    }
  </style>
</head>
<body class="">
  <header>
    <div style="font-weight:800">LEDWall Mapper – Multi-Screen, Snap & Pixel-Perfect</div>
  </header>

  <main>
    <section id="left">
      <div class="panel" style="padding:10px">
        <div id="projectBar" style="display:flex; gap:6px; align-items:center;">
          <input id="projectName" type="text" style="flex:1" placeholder="Nome progetto (es. MainStage)" />
          <button id="saveBtn" title="Salva (JSON)">💾</button>
          <label for="loadFile" class="secondary" style="padding:6px 8px; cursor:pointer" title="Carica (JSON)">📂</label>
          <input id="loadFile" type="file" accept=".json,application/json" style="display:none">
        </div>
        <div style="margin-top:6px"><small>I campi accettano formule: <code>*2</code>, <code>+64</code>, <code>128*3</code>…</small></div>
      </div>

      <div class="panel" style="padding:10px">
        <div style="font-weight:700; margin-bottom:6px">Nuova composizione</div>
        <div>
          <label for="compName">Nome</label>
          <input id="compName" type="text" placeholder="Ledwall Main">
        </div>
        <div class="grid6" style="margin-top:6px">
          <div><label for="cols">Cols</label><input id="cols" type="text" value="8"  placeholder="8, *2"></div>
          <div><label for="rows">Rows</label><input id="rows" type="text" value="4"  placeholder="4, +1"></div>
          <div><label for="tileW">TileW</label><input id="tileW" type="text" value="128" placeholder="128, *2"></div>
          <div><label for="tileH">TileH</label><input id="tileH" type="text" value="128" placeholder="128, -16"></div>
          <div><label for="startX">X</label><input id="startX" type="text" value="0" placeholder="0, +128"></div>
          <div><label for="startY">Y</label><input id="startY" type="text" value="0" placeholder="0, +128"></div>
        </div>
        <button id="addComp" style="margin-top:10px; width:100%">Aggiungi</button>
      </div>

      <div class="panel" style="padding:10px">
        <div style="font-weight:700; margin-bottom:6px">Composizioni</div>
        <div id="recap"></div>
      </div>
    </section>

    <section id="work">
      <div class="panel" style="display:flex; flex-direction:column; gap:8px; min-height:72vh">
        <div id="toolbar">
          <span class="divider"></span>
          <button id="exportBtn" class="icon" title="Esporta PNG">🖼️</button>
          <button id="renameBtn" class="icon" title="Rinomina">✎</button>
          <button id="duplicateBtn" class="icon" title="Duplica">⧉</button>
          <button id="deleteBtn" class="icon" title="Elimina">🗑️</button>
          <span class="divider"></span>
          <div class="palette" title="Palette mattonelle (1–4 colori)">
            <span style="font-size:12px;color:#a8b0bb">Colori</span>
            <select id="tbColorCount" aria-label="Numero colori">
              <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option>
            </select>
            <div class="swatch" id="sw1" title="Colore 1"><div class="preview" id="sw1p" style="background:#3b82f6"></div><input type="color" id="tbCol1" value="#3b82f6"></div>
            <div class="swatch" id="sw2" title="Colore 2"><div class="preview" id="sw2p" style="background:#10b981"></div><input type="color" id="tbCol2" value="#10b981"></div>
            <div class="swatch" id="sw3" title="Colore 3" style="display:none"><div class="preview" id="sw3p" style="background:#f97316"></div><input type="color" id="tbCol3" value="#f97316"></div>
            <div class="swatch" id="sw4" title="Colore 4" style="display:none"><div class="preview" id="sw4p" style="background:#ec4899"></div><input type="color" id="tbCol4" value="#ec4899"></div>
          </div>
          <div class="palette" title="Colore testo nome/dimensione">
            <span style="font-size:12px;color:#a8b0bb">Testo</span>
            <div class="swatch" id="swName" title="Colore testo"><div class="preview" id="swNamePrev" style="background:#ffffff"></div><input type="color" id="tbNameColor" value="#ffffff"></div>
          </div>
          
          <div class="popup-container">
            <button id="toggleFontSizeBtn" class="icon" title="Dimensione e Posizione Testo">Aa</button>
            <div id="fontSizePopup" class="popup">
              <div class="slider-row">
                <span>Size</span>
                <input type="range" id="fontSizeSlider" min="8" max="160" value="24" step="1">
                <span id="fontSizeValue" class="editable-value" contenteditable="true">24px</span>
              </div>
              <div class="slider-row">
                <span>X</span>
                <input type="range" id="nameOffsetXSlider" min="-1000" max="1000" value="0" step="1">
                <span id="nameOffsetXValue" class="editable-value" contenteditable="true">0px</span>
              </div>
              <div class="slider-row">
                <span>Y</span>
                <input type="range" id="nameOffsetYSlider" min="-1000" max="1000" value="0" step="1">
                <span id="nameOffsetYValue" class="editable-value" contenteditable="true">0px</span>
              </div>
            </div>
          </div>

          <div class="popup-container">
            <button id="toggleVisibilityBtn" class="icon" title="Visibilità Elementi">👁️</button>
            <div id="visibilityPopup" class="popup">
              <div class="visibility-row"><span>Nome</span><button data-toggle="name">ON</button></div>
              <div class="visibility-row"><span>Numeri Tile</span><button data-toggle="tileLabels">ON</button></div>
              <div class="visibility-row"><span>Dimensione (px)</span><button data-toggle="size">ON</button></div>
              <div class="visibility-row"><span>Offset TL</span><button data-toggle="offsetTL">ON</button></div>
              <div class="visibility-row"><span>Offset BR</span><button data-toggle="offsetBR">ON</button></div>
              <div class="visibility-row"><span>Bordini Interni</span><button data-toggle="tileLines">ON</button></div>
            </div>
          </div>

          <span class="divider"></span>
          <div class="spacer"></div>

          <div class="zoom-controls">
            <button id="zoomOutBtn" class="secondary">-</button>
            <button id="zoomInBtn" class="secondary">+</button>
          </div>

          <div class="screen-ctrl" title="Gestione schermi">
            <select id="screenSelect" aria-label="Schermo"></select>
            <button id="newScreenBtn" title="Nuovo schermo">Nuovo</button>
          </div>
          <div class="canvas-size" title="Dimensione canvas (formule supportate)">
            <input id="canvasW" type="text" value="1920" placeholder="1920, +10, *2" aria-label="Canvas width">
            <span class="x">×</span>
            <input id="canvasH" type="text" value="1080" placeholder="1080, *2" aria-label="Canvas height">
            <div class="btns">
              <button id="applyCanvas" title="Applica">Applica</button>
              <button id="fit" title="Fit">Fit</button>
            </div>
          </div>
        </div>

        <div id="viewport">
            <div id="screenWrap">
                <div id="screen"></div>
            </div>
            <div id="selectionBox"></div>
        </div>
      </div>
    </section>
  </main>

  <div id="renameModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="renameTitle" style="display:none;">
    <div class="dialog">
      <h3 id="renameTitle">Rinomina composizione</h3>
      <label for="renameInput">Nome</label>
      <input type="text" id="renameInput" autocomplete="off" />
      <div class="row" style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
        <button id="renameCancel" class="secondary">Annulla</button>
        <button id="renameSave">Salva</button>
      </div>
    </div>
  </div>

  <footer>
    <div style="color:#9aa4af; font-size:12px; padding:8px 12px">
      Multi-Screen • Drag fluido • Snap tra rettangoli (prioritario) + griglia (secondaria) • Bordi interni 3px • Linee mattonelle 2px • Auto-fit testo • Offset TL/BR • Recap modificabile • Calcoli inline • Salva/Carica JSON • Palette 1–4 colori in toolbar • Colore nome personalizzabile.
    </div>
    <div id="version">V 0.6.8.0</div>
  </footer>

<script>
(()=> {
  // Helpers
  function evalIntExpression(expr, base) {
    if (typeof expr !== 'string') expr = String(expr ?? '');
    const s = expr.trim();
    if (!s) return NaN;
    const cleaned = s.replace(/[^0-9+\-*/().\s]/g, '');
    let finalExpr = cleaned;
    if (/^[+\-*/]/.test(cleaned)) finalExpr = `(${base}|0)${cleaned}`;
    let out = NaN;
    try { const f = new Function(`return (${finalExpr});`); const val = f(); if (Number.isFinite(val)) out = Math.round(val); }
    catch(_) { out = NaN; }
    return out;
  }
  const px = (n)=> Math.round(n) + 'px';
  const uid = ()=> Math.random().toString(36).slice(2) + Date.now().toString(36);

  // Stato
  const state = { 
    scale: 1, 
    panX: 0,
    panY: 0,
    selected: [],
    defaults: { colorCount:2, colors:['#3b82f6','#10b981','#f97316','#ec4899'], nameColor:'#ffffff' }, 
    screens: [], 
    activeScreenId: null,
    visibility: { name: true, tileLabels: true, size: true, offsetTL: true, offsetBR: true, tileLines: true }
  };
  window.state = state;
  window.collectProject = collectProject;
  
  let marquee = null;
  let isPanning = false;
  let lastPanX, lastPanY;
  let lastPinchDist = 0;
  
  const SNAP_THRESHOLD_EDGE = 12;
  const SNAP_THRESHOLD_GRID = 8;
  const MIN_OFFSET_FONT = 10;
  const TILE_LINE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--tileLine').trim() || '#9fd7ff';

  // DOM
  const mainBody = document.body;
  const viewport = document.getElementById('viewport');
  const screenWrap = document.getElementById('screenWrap');
  const screen = document.getElementById('screen');
  const selectionBox = document.getElementById('selectionBox');
  const projectNameInput = document.getElementById('projectName');
  const saveBtn = document.getElementById('saveBtn');
  const loadFile = document.getElementById('loadFile');
  const compNameInput = document.getElementById('compName');
  const colsInput = document.getElementById('cols');
  const rowsInput = document.getElementById('rows');
  const tileWInput = document.getElementById('tileW');
  const tileHInput = document.getElementById('tileH');
  const startXInput = document.getElementById('startX');
  const startYInput = document.getElementById('startY');
  const addCompBtn = document.getElementById('addComp');
  const renameBtn = document.getElementById('renameBtn');
  const dupBtn = document.getElementById('duplicateBtn');
  const delBtn = document.getElementById('deleteBtn');
  const renameModal = document.getElementById('renameModal');
  const renameInput = document.getElementById('renameInput');
  const renameSave = document.getElementById('renameSave');
  const renameCancel = document.getElementById('renameCancel');
  const canvasWInput = document.getElementById('canvasW');
  const canvasHInput = document.getElementById('canvasH');
  const applyCanvasBtn = document.getElementById('applyCanvas');
  const fitBtn = document.getElementById('fit');
  const tbColorCount = document.getElementById('tbColorCount');
  const tbCol1 = document.getElementById('tbCol1'), tbCol2 = document.getElementById('tbCol2'), tbCol3 = document.getElementById('tbCol3'), tbCol4 = document.getElementById('tbCol4');
  const sw1p = document.getElementById('sw1p'), sw2p = document.getElementById('sw2p'), sw3p = document.getElementById('sw3p'), sw4p = document.getElementById('sw4p');
  const sw3 = document.getElementById('sw3'), sw4 = document.getElementById('sw4');
  const tbNameColor = document.getElementById('tbNameColor');
  const swNamePrev  = document.getElementById('swNamePrev');
  const recap = document.getElementById('recap');
  const screenSelect = document.getElementById('screenSelect');
  const newScreenBtn = document.getElementById('newScreenBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  // DOM per i popup
  const toggleFontSizeBtn = document.getElementById('toggleFontSizeBtn');
  const fontSizePopup = document.getElementById('fontSizePopup');
  const fontSizeSlider = document.getElementById('fontSizeSlider');
  const fontSizeValue = document.getElementById('fontSizeValue');
  const nameOffsetXSlider = document.getElementById('nameOffsetXSlider');
  const nameOffsetXValue = document.getElementById('nameOffsetXValue');
  const nameOffsetYSlider = document.getElementById('nameOffsetYSlider');
  const nameOffsetYValue = document.getElementById('nameOffsetYValue');
  const toggleVisibilityBtn = document.getElementById('toggleVisibilityBtn');
  const visibilityPopup = document.getElementById('visibilityPopup');

  // Funzioni
  function applyCanvasSize(w,h){ screen.style.width = px(w); screen.style.height = px(h); fitToViewport(); clampAllComps(); }
  
  function updateTransform() {
    screenWrap.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
  }
  
  function fitToViewport(){
    const vw = viewport.clientWidth - 16;
    const vh = viewport.clientHeight - 16;
    const sx = vw / getCanvas().w;
    const sy = vh / getCanvas().h;
    state.scale = Math.min(sx, sy, 1);
    state.panX = 0;
    state.panY = 0;
    updateTransform();
  }
  
  function applyZoom(delta, centerX, centerY) {
      const oldScale = state.scale;
      state.scale *= delta;
      state.scale = Math.max(0.1, Math.min(5, state.scale));
      const scaleChange = state.scale - oldScale;
      state.panX -= (centerX - state.panX) * (scaleChange / oldScale);
      state.panY -= (centerY - state.panY) * (scaleChange / oldScale);
      updateTransform();
  }

  function getCanvas() { return getActiveScreen()?.canvas || {w:1920,h:1080}; }
  function clampAllComps(){
    const {w:cw, h:ch} = getCanvas();
    document.querySelectorAll('.comp').forEach(el=>{
      let x = Math.round(parseFloat(el.style.left)||0), y = Math.round(parseFloat(el.style.top)||0);
      const w = el.offsetWidth, h = el.offsetHeight;
      x = Math.max(0, Math.min(cw - w, x));
      y = Math.max(0, Math.min(ch - h, y));
      el.style.left = px(x); el.style.top = px(y);
      updateOffsetLabels(el);
    });
  }

  // ===== Funzioni di Selezione Multipla =====
  function setSelection(els) {
    clearSelection(true); 
    state.selected = Array.isArray(els) ? els : [els];
    state.selected.forEach(el => el.classList.add('selected'));
    updateUIForSelection();
  }
  function addToSelection(el) {
    if (!state.selected.includes(el)) {
      state.selected.push(el);
      el.classList.add('selected');
      updateUIForSelection();
    }
  }
  function removeFromSelection(el) {
    state.selected = state.selected.filter(e => e !== el);
    el.classList.remove('selected');
    updateUIForSelection();
  }
  function clearSelection(silent = false) {
    state.selected.forEach(el => el.classList.remove('selected'));
    state.selected = [];
    if (!silent) updateUIForSelection();
  }
  function selectAll() {
    setSelection(getAllComps());
  }
  function getPrimarySelection() {
    return state.selected.length > 0 ? state.selected[state.selected.length - 1] : null;
  }

  function updateUIForSelection() {
    const primary = getPrimarySelection();
    if (primary) {
      tbColorCount.value = String(parseInt(primary.dataset.colorCount || state.defaults.colorCount,10));
      const cols = getCompColors(primary);
      [tbCol1,tbCol2,tbCol3,tbCol4].forEach((inp,i)=>{ const v=cols[i]||state.defaults.colors[i]; inp.value=v; [sw1p,sw2p,sw3p,sw4p][i].style.background=v; });
      updateToolbarColorVisibility();
      tbNameColor.value = primary.dataset.nameColor || state.defaults.nameColor;
      swNamePrev.style.background = tbNameColor.value;

      const nameEl = primary.querySelector('.name');
      const currentSize = primary.dataset.nameFontSize || Math.round(parseFloat(window.getComputedStyle(nameEl).fontSize));
      fontSizeSlider.value = currentSize;
      fontSizeValue.textContent = currentSize + 'px';
      
      const offsetX = primary.dataset.nameOffsetX || 0;
      nameOffsetXSlider.value = offsetX;
      nameOffsetXValue.textContent = offsetX + 'px';

      const offsetY = primary.dataset.nameOffsetY || 0;
      nameOffsetYSlider.value = offsetY;
      nameOffsetYValue.textContent = offsetY + 'px';

    } else {
        fontSizePopup.classList.remove('visible');
    }
    updateToolbarState();
    highlightRecapSelection();

    if (primary) {
      const primaryId = primary.dataset.id;
      const recapItem = recap.querySelector(`.recap-item[data-id="${primaryId}"]`);
      if (recapItem) {
        recapItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }
  }
  
  function updateToolbarState(){
    const count = state.selected.length;
    dupBtn.disabled = count === 0;
    delBtn.disabled = count === 0;
    renameBtn.disabled = count !== 1;
    toggleFontSizeBtn.disabled = count === 0;

    if (count === 0) fontSizePopup.classList.remove('visible');
  }

  const _measureCanvas = document.createElement('canvas');
  const _mctx = _measureCanvas.getContext('2d');
  const FONT_FAMILY = "system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
  function textWidthPx(text, weight, sizePx) { _mctx.font = `${weight} ${sizePx}px ${FONT_FAMILY}`; return Math.ceil(_mctx.measureText(text).width); }
  function maxFontThatFits(text, weight, maxWidth, maxHeight, minPx=8, maxPx=160) {
    let lo=minPx, hi=maxPx, best=minPx;
    while (lo<=hi) { const mid=(lo+hi>>1); const w=textWidthPx(text,weight,mid), h=Math.ceil(mid*1.1);
      if (w<=maxWidth && h<=maxHeight) { best=mid; lo=mid+1; } else { hi=mid-1; } }
    return best;
  }
  
  function positionSizeLabel(el) {
    const sizeEl = el.querySelector('.size');
    if (!sizeEl) return;
    const tileH = parseInt(el.dataset.tileH || '128', 10);
    sizeEl.style.bottom = px(tileH / 2);
    sizeEl.style.transform = 'translate(-50%, 50%)';
  }

  function applyNameTransform(el) {
    const nameEl = el.querySelector('.name');
    if (!nameEl) return;
    const x = el.dataset.nameOffsetX || 0;
    const yBase = (el.dataset.nameOffsetY || 0) * -1;
    const nudge = -4; 
    nameEl.style.transform = `translate(${x}px, ${yBase + nudge}px)`;
  }

  function fitLabels(el) {
    const nameEl = el.querySelector('.name'), sizeEl = el.querySelector('.size'), offTL  = el.querySelector('.offset'), offBR  = el.querySelector('.offsetBR');
    if (nameEl && sizeEl) {
      const padH=16, padV=8, innerW=el.clientWidth - padH, innerH=el.clientHeight - padV;
      if (el.dataset.nameFontSize) {
        nameEl.style.fontSize = el.dataset.nameFontSize + "px";
      } else {
        const namePx = maxFontThatFits(nameEl.textContent||"", "800", innerW, Math.max(10, Math.floor(innerH*0.70)), 8, 160);
        nameEl.style.fontSize = namePx + "px";
      }
      sizeEl.style.fontSize = maxFontThatFits(sizeEl.textContent||"", "400", innerW, Math.max(10, Math.floor(innerH*0.25)), 8, 64) + "px";
    }
    [offTL, offBR].forEach(elCorner => {
      if (!elCorner) return;
      const f = maxFontThatFits(elCorner.textContent||"", "600", Math.max(20, Math.floor(el.clientWidth*0.55)-8), Math.max(10, Math.floor(el.clientHeight*0.18)-6), 9, 22);
      elCorner.style.display = (f < MIN_OFFSET_FONT) ? 'none' : 'inline-block';
      if (f >= MIN_OFFSET_FONT) elCorner.style.fontSize = f + 'px';
    });
  }

  function updateOffsetLabels(el){
    const x = Math.round(parseFloat(el.style.left) || 0), y = Math.round(parseFloat(el.style.top)  || 0);
    const w = el.offsetWidth, h = el.offsetHeight;
    el.querySelector('.offset').textContent = `(${x}, ${y})`;
    el.querySelector('.offsetBR').textContent = `(${x + w - 1}, ${y + h - 1})`;
    positionSizeLabel(el);
    fitLabels(el);
    refreshRecap();
  }

  function getCompColors(el){
    const count = parseInt(el?.dataset.colorCount || state.defaults.colorCount, 10);
    const arr = [el?.dataset.c1, el?.dataset.c2, el?.dataset.c3, el?.dataset.c4].map((c,i) => c || state.defaults.colors[i]);
    return arr.slice(0, Math.max(1, Math.min(4, count)));
  }
  function makePatternDataURL(colors, tileW, tileH){
    const n = colors.length;
    let pattCols = 1, pattRows = 1;
    if (n === 2 || n === 4) { pattCols=2; pattRows=2; }
    else if (n === 3) { pattCols=3; pattRows=3; }
    const W = tileW*pattCols, H = tileH*pattRows;
    const c = document.createElement('canvas'); c.width = W; c.height = H;
    const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = false;
    for (let r=0; r<pattRows; r++){
      for (let q=0; q<pattCols; q++){
        let color;
        if (n===1) color = colors[0];
        else if (n===2) color = colors[(r+q)%2];
        else if (n===3) color = colors[(r+q)%3];
        else color = colors[r*2 + q];
        const x = q*tileW, y = r*tileH;
        
        const borderWidth = state.visibility.tileLines ? 1 : 0;
        if (borderWidth > 0) {
          ctx.fillStyle = TILE_LINE_COLOR; 
          ctx.fillRect(x, y, tileW, tileH);
        }
        
        const iw = tileW - (borderWidth * 2);
        const ih = tileH - (borderWidth * 2);
        if (iw > 0 && ih > 0) {
            ctx.fillStyle = color;
            ctx.fillRect(x + borderWidth, y + borderWidth, iw, ih);
        } else {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, tileW, tileH);
        }
      }
    }
    return { url: c.toDataURL(), pattW: W, pattH: H };
  }
  function applyCompBackground(el){
    const tileW = parseInt(el.dataset.tileW||'1',10), tileH = parseInt(el.dataset.tileH||'1',10);
    const { url, pattW, pattH } = makePatternDataURL(getCompColors(el), tileW, tileH);
    el.style.backgroundImage = `url("${url}")`;
    el.style.backgroundSize  = `${pattW}px ${pattH}px`;
  }
  
  function refreshAllCompBackgrounds() {
    getAllComps().forEach(el => applyCompBackground(el));
  }

  function makeDraggable(el){
    let drag = null;
    const getPos = (e)=>{ if(e.touches&&e.touches[0]) e=e.touches[0]; return {x:e.clientX,y:e.clientY}; };
    
    const start = (e)=>{
      if (e.button === 1) return; // Ignora il tasto centrale per il drag

      e.preventDefault();
      e.stopPropagation();

      if (e.shiftKey) {
        state.selected.includes(el) ? removeFromSelection(el) : addToSelection(el);
      } else {
        if (!state.selected.includes(el)) {
          setSelection(el);
        }
      }
      
      const p = getPos(e);
      const pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top) / state.scale;

      drag = {
        initialPositions: new Map(state.selected.map(comp => [comp, { x: parseFloat(comp.style.left) || 0, y: parseFloat(comp.style.top) || 0 }])),
        draggedComp: el,
        clickOffsetX: pointerWorldX - (parseFloat(el.style.left) || 0),
        clickOffsetY: pointerWorldY - (parseFloat(el.style.top) || 0)
      };
      
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', end);
      window.addEventListener('touchmove', move, { passive: false });
      window.addEventListener('touchend', end);
    };

    const move = (e)=>{
      if(!drag) return; 
      e.preventDefault(); e.stopPropagation();
      const p = getPos(e), pg = screen.getBoundingClientRect();
      const pointerWorldX = (p.x - pg.left) / state.scale;
      const pointerWorldY = (p.y - pg.top) / state.scale;
      
      let nx = pointerWorldX - drag.clickOffsetX;
      let ny = pointerWorldY - drag.clickOffsetY;
      const w = drag.draggedComp.offsetWidth;
      const h = drag.draggedComp.offsetHeight;

      const Lm = nx, Rm = nx + w;
      const Tm = ny, Bm = ny + h;
      let snappedX = false, snappedY = false;
      const otherComps = getAllComps().filter(c => !state.selected.includes(c));

      for (const n of otherComps){
        const left = parseFloat(n.style.left)||0, top = parseFloat(n.style.top)||0;
        const nw = n.offsetWidth, nh = n.offsetHeight;
        const Lt = left, Rt = left+nw, Tt = top, Bt = top+nh;
        
        if (Math.abs(Lm - Lt) < SNAP_THRESHOLD_EDGE) { nx = Lt; snappedX = true; }
        else if (Math.abs(Lm - Rt) < SNAP_THRESHOLD_EDGE) { nx = Rt; snappedX = true; }
        else if (Math.abs(Rm - Lt) < SNAP_THRESHOLD_EDGE) { nx = Lt - w; snappedX = true; }
        else if (Math.abs(Rm - Rt) < SNAP_THRESHOLD_EDGE) { nx = Rt - w; snappedX = true; }

        if (Math.abs(Tm - Tt) < SNAP_THRESHOLD_EDGE) { ny = Tt; snappedY = true; }
        else if (Math.abs(Tm - Bt) < SNAP_THRESHOLD_EDGE) { ny = Bt; snappedY = true; }
        else if (Math.abs(Bm - Tt) < SNAP_THRESHOLD_EDGE) { ny = Tt - h; snappedY = true; }
        else if (Math.abs(Bm - Bt) < SNAP_THRESHOLD_EDGE) { ny = Bt - h; snappedY = true; }
      }

      if (!snappedX) {
        const tileW = parseInt(drag.draggedComp.dataset.tileW || '1', 10) || 1;
        const gx = Math.round(nx / tileW) * tileW;
        if (Math.abs(nx - gx) <= SNAP_THRESHOLD_GRID) nx = gx;
      }
      if (!snappedY) {
        const tileH = parseInt(drag.draggedComp.dataset.tileH || '1', 10) || 1;
        const gy = Math.round(ny / tileH) * tileH;
        if (Math.abs(ny - gy) <= SNAP_THRESHOLD_GRID) ny = gy;
      }
      
      const initialDraggedPos = drag.initialPositions.get(drag.draggedComp);
      const dx = nx - initialDraggedPos.x;
      const dy = ny - initialDraggedPos.y;
      const {w:cw, h:ch} = getCanvas();

      drag.initialPositions.forEach((pos, comp) => {
        let finalX = pos.x + dx;
        let finalY = pos.y + dy;

        finalX = Math.round(Math.max(0, Math.min(cw - comp.offsetWidth, finalX)));
        finalY = Math.round(Math.max(0, Math.min(ch - comp.offsetHeight, finalY)));

        comp.style.left = px(finalX);
        comp.style.top = px(finalY);
        updateOffsetLabels(comp);
      });
    };
    const end = ()=>{ 
      drag = null; 
      window.removeEventListener('mousemove', move); 
      window.removeEventListener('mouseup', end); 
      window.removeEventListener('touchmove', move); 
      window.removeEventListener('touchend', end); 
    };
    
    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start, { passive:false });
    el.removeEventListener('click', el.clickHandler);
    el.clickHandler = e => e.stopPropagation();
    el.addEventListener('click', el.clickHandler);
  }

  function setNameColor(el, color){
    el.dataset.nameColor = color;
    el.querySelector('.name').style.color = color;
    el.querySelector('.size').style.color = color;
  }
  function addComposition(){
    const scr = getActiveScreen(); if (!scr) return;
    const name = (compNameInput.value || `Composizione`).trim();
    const cols  = Math.max(1, evalIntExpression(colsInput.value,  8) ?? 8);
    const rows  = Math.max(1, evalIntExpression(rowsInput.value,  4) ?? 4);
    const tileW = Math.max(1, evalIntExpression(tileWInput.value, 128)   ?? 128);
    const tileH = Math.max(1, evalIntExpression(tileHInput.value, 128)   ?? 128);
    let   nx    = Math.max(0, evalIntExpression(startXInput.value, 0)  ?? 0);
    let   ny    = Math.max(0, evalIntExpression(startYInput.value, 0)  ?? 0);
    const w = cols * tileW;
    const h = rows * tileH;
    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = uid();
    el.style.width = px(w);
    el.style.height = px(h);
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);
    el.dataset.colorCount = tbColorCount.value;
    el.dataset.c1 = tbCol1.value;
    el.dataset.c2 = tbCol2.value;
    el.dataset.c3 = tbCol3.value;
    el.dataset.c4 = tbCol4.value;
    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = name; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}×${h}px`; el.appendChild(sizeEl);
    setNameColor(el, tbNameColor.value);
    const {w:cw, h:ch} = scr.canvas;
    el.style.left = px(Math.min(cw - w, nx));
    el.style.top  = px(Math.min(ch - h, ny));
    screen.appendChild(el);
    renderTileLabels(el, cols, rows, tileW, tileH);
    makeDraggable(el);
    applyCompBackground(el);
    updateOffsetLabels(el);
    applyNameTransform(el);
    setSelection(el);
  }

  const renameOpen = ()=>{ if(state.selected.length !== 1) return; const target = state.selected[0]; renameInput.value = target.querySelector('.name').textContent || ""; renameModal.style.display='flex'; renameInput.focus(); renameInput.select(); };
  const renameClose= ()=>{ renameModal.style.display='none'; };
  const renameSaveFn = ()=>{ if(state.selected.length !== 1) return; const v=(renameInput.value||"").trim(); if(v){ state.selected[0].querySelector('.name').textContent=v; fitLabels(state.selected[0]); refreshRecap(); } renameClose(); };
  renameBtn.addEventListener('click', renameOpen);
  renameCancel.addEventListener('click', renameClose);
  renameSave.addEventListener('click', renameSaveFn);
  renameModal.addEventListener('click', (e)=>{ if(e.target===renameModal) renameClose(); });
  renameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') renameSaveFn(); if(e.key==='Escape') renameClose(); });

  dupBtn.addEventListener('click', ()=>{
    const newSelection = [];
    [...state.selected].forEach(src => {
        const {offsetWidth:w, offsetHeight:h, dataset} = src;
        const tileW = parseInt(dataset.tileW,10), tileH = parseInt(dataset.tileH,10);
        const cols = Math.round(w/tileW), rows = Math.round(h/tileH);
        const el = document.createElement('div');
        el.className = 'comp';
        Object.assign(el.dataset, {...dataset, id:uid()});
        el.style.width = px(w);
        el.style.height = px(h);
        const name = (src.querySelector('.name').textContent || 'Composizione') + ' Copy';
        const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
        const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
        const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = name; el.appendChild(nameEl);
        const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}×${h}px`; el.appendChild(sizeEl);
        setNameColor(el, src.dataset.nameColor);
        const {w:cw, h:ch} = getCanvas();
        el.style.left = px(Math.min(cw - w, Math.max(0, (parseFloat(src.style.left)||0) + 24)));
        el.style.top  = px(Math.min(ch - h, Math.max(0, (parseFloat(src.style.top)||0) + 24)));
        screen.appendChild(el);
        renderTileLabels(el, cols, rows, tileW, tileH);
        makeDraggable(el);
        applyCompBackground(el);
        updateOffsetLabels(el);
        applyNameTransform(el);
        newSelection.push(el);
    });
    setSelection(newSelection);
  });
  delBtn.addEventListener('click', ()=>{
    [...state.selected].forEach(el => el.remove());
    clearSelection();
  });

  function applyCanvasFromInputs(){
    const scr = getActiveScreen(); if(!scr) return;
    scr.canvas.w = Math.max(1, evalIntExpression(canvasWInput.value, scr.canvas.w) || scr.canvas.w);
    scr.canvas.h = Math.max(1, evalIntExpression(canvasHInput.value, scr.canvas.h) || scr.canvas.h);
    applyCanvasSize(scr.canvas.w, scr.canvas.h);
    canvasWInput.value = String(scr.canvas.w);
    canvasHInput.value = String(scr.canvas.h);
  }
  applyCanvasBtn.addEventListener('click', applyCanvasFromInputs);
  fitBtn.addEventListener('click', fitToViewport);

  function updateToolbarColorVisibility(){ sw3.style.display=sw4.style.display = parseInt(tbColorCount.value,10)>2?'':'none'; sw4.style.display=parseInt(tbColorCount.value,10)>3?'':'none'; }
  updateToolbarColorVisibility();
  tbColorCount.addEventListener('change', ()=>{
    updateToolbarColorVisibility();
    state.selected.forEach(el => {
        el.dataset.colorCount = tbColorCount.value;
        applyCompBackground(el);
    });
    if(state.selected.length === 0) state.defaults.colorCount = parseInt(tbColorCount.value,10);
  });
  [tbCol1,tbCol2,tbCol3,tbCol4].forEach((inp, i)=>{
    inp.addEventListener('input', ()=>{
      const color = inp.value;
      [sw1p,sw2p,sw3p,sw4p][i].style.background = color;
      state.selected.forEach(el => {
        el.dataset['c'+(i+1)] = color;
        applyCompBackground(el);
      });
      if(state.selected.length === 0) state.defaults.colors[i] = color;
    });
  });
  tbNameColor.addEventListener('input', ()=>{
    const color = tbNameColor.value;
    swNamePrev.style.background = color;
    state.selected.forEach(el => setNameColor(el, color));
    if(state.selected.length === 0) state.defaults.nameColor = color;
  });

  // Recap
  function getAllComps(){ return [...document.querySelectorAll('.comp')]; }
  function compData(el){
    const w = el.offsetWidth, h = el.offsetHeight;
    const tileW = parseInt(el.dataset.tileW||'1',10)||1;
    const tileH = parseInt(el.dataset.tileH||'1',10)||1;
    const cols = Math.round(w / tileW);
    const rows = Math.round(h / tileH);
    const x = Math.round(parseFloat(el.style.left)||0);
    const y = Math.round(parseFloat(el.style.top) ||0);
    const name = el.querySelector('.name')?.textContent || '';
    const id = el.dataset.id || '';
    return {id, name, cols, rows, tileW, tileH, w, h, x, y};
  }
  function refreshRecap(){
    const items = getAllComps().map(compData);
    recap.innerHTML = '';
    for (const it of items){
      const row = document.createElement('div');
      row.className = 'recap-item';
      row.dataset.id = it.id;
      if (state.selected.find(el => el.dataset.id === it.id)) row.classList.add('selected');

      const makeEditable = (label, value, field, widthCh=6)=>{
        const span = document.createElement('span');
        span.className = 'pill editable';
        span.style.minWidth = `${widthCh}ch`;
        span.contentEditable = 'true';
        span.spellcheck = false;
        span.dataset.field = field;
        span.dataset.base = String(value);
        span.textContent = String(value);
        span.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); span.blur(); } });
        span.addEventListener('focus', ()=> setSelection(document.querySelector(`[data-id="${it.id}"]`)));
        span.addEventListener('blur', ()=> applyEdit(it.id, field, span.textContent, Number(span.dataset.base)));
        const lab = document.createElement('span');
        lab.className = 'pill'; lab.textContent = label; lab.style.marginRight='4px';
        const group = document.createElement('span');
        group.style.display='inline-flex'; group.style.alignItems='center'; group.style.gap='6px';
        group.append(lab, span);
        return group;
      };

      const sep = ()=>{ const s=document.createElement('span'); s.className='sep'; s.textContent='•'; return s; }

      const nameEl = makeEditable('Nome', it.name, 'name', Math.max(6, it.name.length));
      const colsEl = makeEditable('Cols', it.cols, 'cols', 4);
      const rowsEl = makeEditable('Rows',  it.rows, 'rows', 4);
      const twEl   = makeEditable('TileW', it.tileW,'tileW', 5);
      const thEl   = makeEditable('TileH', it.tileH,'tileH', 5);
      const xEl    = makeEditable('X', it.x, 'x', 4);
      const yEl    = makeEditable('Y', it.y, 'y', 4);

      const tot = document.createElement('span'); tot.className='pill'; tot.textContent = `Tot: ${it.w}×${it.h}px`;

      row.append(nameEl, sep());
      const groupTiles = document.createElement('span'); groupTiles.className='pill'; groupTiles.style.gap='6px'; groupTiles.style.display='inline-flex'; groupTiles.style.alignItems='center'; groupTiles.style.background='transparent'; groupTiles.style.border='none'; groupTiles.style.padding='0';
      groupTiles.append('Tiles:', colsEl.querySelector('.editable'), document.createTextNode('×'), rowsEl.querySelector('.editable'));
      row.append(groupTiles, sep());
      const groupPix = document.createElement('span'); groupPix.className='pill'; groupPix.style.gap='6px'; groupPix.style.display='inline-flex'; groupPix.style.alignItems='center'; groupPix.style.background='transparent'; groupPix.style.border='none'; groupPix.style.padding='0';
      groupPix.append('Tile(px):', twEl.querySelector('.editable'), document.createTextNode('×'), thEl.querySelector('.editable'));
      row.append(groupPix, sep(), tot, sep());
      const groupOff = document.createElement('span'); groupOff.className='pill'; groupOff.style.gap='6px'; groupOff.style.display='inline-flex'; groupOff.style.alignItems='center'; groupOff.style.background='transparent'; groupOff.style.border='none'; groupOff.style.padding='0';
      groupOff.append('Offset:', xEl.querySelector('.editable'), document.createTextNode(','), yEl.querySelector('.editable'));
      row.append(groupOff);

      row.addEventListener('click', (e)=> { if(!(e.target instanceof HTMLElement && e.target.isContentEditable)){ setSelection(document.querySelector(`[data-id="${it.id}"]`)); } });
      recap.appendChild(row);
    }
  }
  
  function highlightRecapSelection(){
    recap.querySelectorAll('.recap-item').forEach(r=>{
      r.classList.toggle('selected', !!state.selected.find(el => el.dataset.id === r.dataset.id));
    });
  }
  function applyEdit(id, field, rawValue, baseValue){
    const el = getAllComps().find(n=> n.dataset.id===id);
    if (!el) return;

    let w = el.offsetWidth, h = el.offsetHeight;
    let tileW = parseInt(el.dataset.tileW||'1',10)||1;
    let tileH = parseInt(el.dataset.tileH||'1',10)||1;
    let cols = Math.round(w / tileW);
    let rows = Math.round(h / tileH);
    let x = Math.round(parseFloat(el.style.left)||0);
    let y = Math.round(parseFloat(el.style.top) ||0);

    if (field === 'name'){
      const text = (rawValue||'').trim();
      if (text) { el.querySelector('.name').textContent = text; fitLabels(el); }
      refreshRecap(); return;
    }

    const v = evalIntExpression(rawValue, baseValue);
    if (!Number.isFinite(v)) { refreshRecap(); return; }

    switch(field){
      case 'cols': cols = Math.max(1, v); w = cols * tileW; break;
      case 'rows': rows = Math.max(1, v); h = rows * tileH; break;
      case 'tileW': tileW = Math.max(1, v); el.dataset.tileW = String(tileW); w = cols * tileW; break;
      case 'tileH': tileH = Math.max(1, v); el.dataset.tileH = String(tileH); h = rows * tileH; break;
      case 'x': x = Math.max(0, v); break;
      case 'y': y = Math.max(0, v); break;
    }

    const {w:cw, h:ch} = getCanvas();
    w = Math.max(1, Math.min(cw, w));
    h = Math.max(1, Math.min(ch, h));
    x = Math.min(cw - w, Math.max(0, x));
    y = Math.min(ch - h, Math.max(0, y));

    el.style.width = px(w);
    el.style.height = px(h);
    el.dataset.tileW = String(tileW);
    el.dataset.tileH = String(tileH);
    el.querySelector('.size').textContent = `${w}×${h}px`;
    el.style.left = px(x);
    el.style.top  = px(y);
    applyCompBackground(el);
    updateOffsetLabels(el);
    renderTileLabels(el, cols, rows, tileW, tileH);
    setSelection(el);
    refreshRecap();
    persistCurrentScreen();
  }
  
  // Salva/Carica
  function collectCurrentScreen(){
    const scr = getActiveScreen(); if(!scr) return;
    scr.compositions = getAllComps().map(el=>{
      const {offsetWidth:w, offsetHeight:h, dataset} = el;
      const nameEl = el.querySelector('.name');
      const finalNameFontSize = dataset.nameFontSize || Math.round(parseFloat(window.getComputedStyle(nameEl).fontSize));

      return { 
        id:dataset.id, 
        name: nameEl.textContent||'', 
        cols:Math.round(w/dataset.tileW), 
        rows:Math.round(h/dataset.tileH), 
        tileW:parseInt(dataset.tileW), 
        tileH:parseInt(dataset.tileH), 
        x:Math.round(parseFloat(el.style.left)||0), 
        y:Math.round(parseFloat(el.style.top)||0), 
        colorCount:parseInt(dataset.colorCount), 
        colors:[dataset.c1,dataset.c2,dataset.c3,dataset.c4], 
        nameColor:dataset.nameColor, 
        nameFontSize: finalNameFontSize, 
        nameOffsetX: dataset.nameOffsetX, 
        nameOffsetY: dataset.nameOffsetY 
      };
    });
  }
  function persistCurrentScreen(){ collectCurrentScreen(); }
  function collectProject(){ persistCurrentScreen(); return {version:5, name:(projectNameInput.value||'Progetto').trim(), defaults:state.defaults, screens:state.screens }; }
  function saveProject(){ const data=collectProject(); const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${(data.name||'progetto').replace(/[^a-z0-9_\-]+/gi,'_').toLowerCase()}.json`; a.click(); URL.revokeObjectURL(a.href); }
  function clearCanvas(){ getAllComps().forEach(el=>el.remove()); state.selected = []; updateToolbarState(); refreshRecap(); }
  
  function createCompFromData(c){
    const w = c.cols * c.tileW, h = c.rows * c.tileH;
    const el = document.createElement('div');
    el.className = 'comp';
    el.dataset.id = c.id || uid();
    el.style.width = px(w);
    el.style.height = px(h);
    el.dataset.tileW = String(c.tileW);
    el.dataset.tileH = String(c.tileH);
    el.dataset.colorCount = String(c.colorCount ?? 2);
    const arr = c.colors || [];
    el.dataset.c1 = arr[0] || state.defaults.colors[0];
    el.dataset.c2 = arr[1] || state.defaults.colors[1];
    el.dataset.c3 = arr[2] || state.defaults.colors[2];
    el.dataset.c4 = arr[3] || state.defaults.colors[3];
    Object.assign(el.dataset, { nameColor:c.nameColor, nameFontSize:c.nameFontSize, nameOffsetX:c.nameOffsetX, nameOffsetY:c.nameOffsetY });
    const offTL = document.createElement('div'); offTL.className = 'offset'; el.appendChild(offTL);
    const offBR = document.createElement('div'); offBR.className = 'offsetBR'; el.appendChild(offBR);
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = c.name || 'Composizione'; el.appendChild(nameEl);
    const sizeEl = document.createElement('div'); sizeEl.className = 'size'; sizeEl.textContent = `${w}×${h}px`; el.appendChild(sizeEl);
    setNameColor(el, c.nameColor || state.defaults.nameColor);
    if(c.nameFontSize) {
        nameEl.style.fontSize = c.nameFontSize + 'px';
    }
    el.style.left = px(c.x);
    el.style.top  = px(c.y);
    screen.appendChild(el);
    renderTileLabels(el, c.cols, c.rows, c.tileW, c.tileH);
    makeDraggable(el); applyCompBackground(el); updateOffsetLabels(el); applyNameTransform(el);
  }
  function loadScreenIntoDOM(screenObj){
    applyCanvasSize(screenObj.canvas.w, screenObj.canvas.h);
    canvasWInput.value = screenObj.canvas.w; canvasHInput.value = screenObj.canvas.h;
    clearCanvas();
    (screenObj.compositions||[]).forEach(createCompFromData);
    refreshRecap();
  }
  function loadProjectFromObject(obj){
    if (!obj || typeof obj !== 'object') return;
    Object.assign(state.defaults, obj.defaults);
    state.screens = obj.screens || [{ id: uid(), name: 'Schermo 1', canvas: { w: 1920, h: 1080 }, compositions: [] }];
    projectNameInput.value = obj.name || '';
    state.activeScreenId = state.screens[0]?.id;
    updateScreenSelect();
    if (getActiveScreen()) loadScreenIntoDOM(getActiveScreen());
  }
  function getActiveScreen(){ return state.screens.find(s=> s.id===state.activeScreenId) || null; }
  function updateScreenSelect(){
    screenSelect.innerHTML = state.screens.map(s => `<option value="${s.id}">${s.name} (${s.canvas.w}×${s.canvas.h})</option>`).join('');
    if (!state.screens.find(s=> s.id===state.activeScreenId) && state.screens[0]) state.activeScreenId = state.screens[0].id;
    screenSelect.value = state.activeScreenId || (state.screens[0]?.id || '');
  }

  // Funzione per rendere i valori editabili
  function setupEditableValue(valueSpan, slider) {
    let lastValidValue = '';
    valueSpan.addEventListener('focus', () => {
        lastValidValue = slider.value;
        setTimeout(() => {
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(valueSpan);
            selection.removeAllRanges();
            selection.addRange(range);
        }, 0);
    });
    const updateFromInput = () => {
        const text = valueSpan.textContent || '';
        const newValue = parseInt(text, 10);
        if (!isNaN(newValue) && newValue >= parseInt(slider.min) && newValue <= parseInt(slider.max)) {
            slider.value = newValue;
            slider.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
            valueSpan.textContent = lastValidValue + 'px';
        }
    };
    valueSpan.addEventListener('blur', updateFromInput);
    valueSpan.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            valueSpan.blur();
        } else if (e.key === 'Escape') {
            valueSpan.textContent = lastValidValue + 'px';
            valueSpan.blur();
        }
    });
  }
  
  // Gestione visibilità
  function applyVisibilityState() {
    for (const key in state.visibility) {
      const classMap = { name: 'hide-names', size: 'hide-sizes', tileLabels: 'hide-tile-labels', offsetTL: 'hide-offset-tl', offsetBR: 'hide-offset-br' };
      const button = visibilityPopup.querySelector(`[data-toggle="${key}"]`);
      const isActive = state.visibility[key];
      
      if (button) {
        button.textContent = isActive ? 'ON' : 'OFF';
        button.classList.toggle('active', isActive);
      }
      
      if (classMap[key]) {
        mainBody.classList.toggle(classMap[key], !isActive);
      }
    }
    if ('tileLines' in state.visibility) {
      refreshAllCompBackgrounds();
    }
  }

  // Eventi e Boot
  saveBtn.addEventListener('click', saveProject);
  loadFile.addEventListener('change', (e)=>{ const file = e.target.files?.[0]; if(!file) return; const reader=new FileReader(); reader.onload=(ev)=>{ try{const obj=JSON.parse(String(ev.target?.result||'{}')); loadProjectFromObject(obj);}catch(err){alert('File non valido.');}}; reader.readAsText(file); e.target.value=''; });
  addCompBtn.addEventListener('click', ()=>{ addComposition(); persistCurrentScreen(); });
  new ResizeObserver(fitToViewport).observe(viewport);
  window.addEventListener('orientationchange', ()=>setTimeout(fitToViewport,0));
  
  toggleFontSizeBtn.addEventListener('click', (e) => { e.stopPropagation(); if(toggleFontSizeBtn.disabled) return; visibilityPopup.classList.remove('visible'); fontSizePopup.classList.toggle('visible'); });
  fontSizeSlider.addEventListener('input', ()=>{ if (state.selected.length === 0) return; const size=fontSizeSlider.value; state.selected.forEach(el => { el.dataset.nameFontSize = size; el.querySelector('.name').style.fontSize = size + 'px'; }); fontSizeValue.textContent = size + 'px'; });
  nameOffsetXSlider.addEventListener('input', ()=>{ if (state.selected.length === 0) return; const val=nameOffsetXSlider.value; state.selected.forEach(el => { el.dataset.nameOffsetX = val; applyNameTransform(el); }); nameOffsetXValue.textContent = val + 'px'; });
  nameOffsetYSlider.addEventListener('input', ()=>{ if (state.selected.length === 0) return; const val=nameOffsetYSlider.value; state.selected.forEach(el => { el.dataset.nameOffsetY = val; applyNameTransform(el); }); nameOffsetYValue.textContent = val + 'px'; });

  toggleVisibilityBtn.addEventListener('click', (e) => { e.stopPropagation(); fontSizePopup.classList.remove('visible'); visibilityPopup.classList.toggle('visible'); });
  visibilityPopup.addEventListener('click', (e) => {
    const button = e.target.closest('[data-toggle]');
    if (!button) return;
    const key = button.dataset.toggle;
    if (key in state.visibility) {
      state.visibility[key] = !state.visibility[key];
      applyVisibilityState();
    }
  });

  window.addEventListener('click', (e) => {
    if (fontSizePopup.classList.contains('visible') && !fontSizePopup.contains(e.target) && e.target !== toggleFontSizeBtn) {
        fontSizePopup.classList.remove('visible');
    }
    if (visibilityPopup.classList.contains('visible') && !visibilityPopup.contains(e.target) && e.target !== toggleVisibilityBtn) {
        visibilityPopup.classList.remove('visible');
    }
  });

  window.addEventListener('keydown', (e) => {
      if ((e.key === 'a' || e.key === 'A') && e.ctrlKey) {
          e.preventDefault();
          selectAll();
      }
  });
  
  // Inizializzazione Zoom/Pan
  const center = { x: viewport.clientWidth / 2, y: viewport.clientHeight / 2 };
  zoomInBtn.addEventListener('click', () => applyZoom(1.2, center.x, center.y));
  zoomOutBtn.addEventListener('click', () => applyZoom(1 / 1.2, center.x, center.y));
  viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      applyZoom(e.deltaY > 0 ? 0.9 : 1.1, mouseX, mouseY);
  });
  viewport.addEventListener('mousedown', e => {
      if (e.button === 1) { // MODIFICA: Pan solo con tasto centrale
          isPanning = true;
          lastPanX = e.clientX;
          lastPanY = e.clientY;
      }
  });
  window.addEventListener('mousemove', e => {
      if (!isPanning) return;
      state.panX += e.clientX - lastPanX;
      state.panY += e.clientY - lastPanY;
      lastPanX = e.clientX;
      lastPanY = e.clientY;
      updateTransform();
  });
  window.addEventListener('mouseup', () => isPanning = false);
  
  // Pan & Zoom Touch
  viewport.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const t1 = e.touches[0], t2 = e.touches[1];
      lastPinchDist = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
    }
  }, { passive: false });

  viewport.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const t1 = e.touches[0], t2 = e.touches[1];
      const newDist = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
      const rect = viewport.getBoundingClientRect();
      const centerX = (t1.clientX + t2.clientX) / 2 - rect.left;
      const centerY = (t1.clientY + t2.clientY) / 2 - rect.top;
      if (lastPinchDist) applyZoom(newDist / lastPinchDist, centerX, centerY);
      lastPinchDist = newDist;
    }
  }, { passive: false });

  viewport.addEventListener('touchend', e => {
    if (e.touches.length < 2) lastPinchDist = 0;
  });

  // GESTIONE SELEZIONE A RETTANGOLO
  viewport.addEventListener('mousedown', e => {
    if (e.button !== 0 || e.target !== screen) return;
    e.preventDefault();

    const screenRect = screen.getBoundingClientRect();
    const viewportRect = viewport.getBoundingClientRect();

    marquee = {
        startX: (e.clientX - screenRect.left) / state.scale,
        startY: (e.clientY - screenRect.top) / state.scale,
        startX_vp: e.clientX - viewportRect.left,
        startY_vp: e.clientY - viewportRect.top,
        shiftKey: e.shiftKey,
        startClientX: e.clientX,
        startClientY: e.clientY
    };
    
    if (!e.shiftKey) { clearSelection(); }
    
    selectionBox.style.left = px(marquee.startX_vp);
    selectionBox.style.top = px(marquee.startY_vp);
    selectionBox.style.width = '0px';
    selectionBox.style.height = '0px';
    selectionBox.style.display = 'block';

    window.addEventListener('mousemove', moveMarquee);
    window.addEventListener('mouseup', endMarquee);
  });

  function moveMarquee(e) {
      if (!marquee) return;
      const viewportRect = viewport.getBoundingClientRect();
      const currentX_vp = e.clientX - viewportRect.left;
      const currentY_vp = e.clientY - viewportRect.top;
      
      const left = Math.min(marquee.startX_vp, currentX_vp);
      const top = Math.min(marquee.startY_vp, currentY_vp);
      const width = Math.abs(currentX_vp - marquee.startX_vp);
      const height = Math.abs(currentY_vp - marquee.startY_vp);

      selectionBox.style.left = px(left);
      selectionBox.style.top = px(top);
      selectionBox.style.width = px(width);
      selectionBox.style.height = px(height);
  }

  function endMarquee(e) {
      if (!marquee) return;
      selectionBox.style.display = 'none';
      const dist = Math.hypot(e.clientX - marquee.startClientX, e.clientY - marquee.startClientY);

      if (dist > 5) {
          const screenRect = screen.getBoundingClientRect();
          const endX = (e.clientX - screenRect.left) / state.scale;
          const endY = (e.clientY - screenRect.top) / state.scale;

          const selectionRect = {
              x1: Math.min(marquee.startX, endX),
              y1: Math.min(marquee.startY, endY),
              x2: Math.max(marquee.startX, endX),
              y2: Math.max(marquee.startY, endY)
          };

          const itemsToSelect = [];
          getAllComps().forEach(comp => {
              const compRect = { x1: comp.offsetLeft, y1: comp.offsetTop, x2: comp.offsetLeft + comp.offsetWidth, y2: comp.offsetTop + comp.offsetHeight };
              const intersects = (compRect.x1 < selectionRect.x2 && compRect.x2 > selectionRect.x1 && compRect.y1 < selectionRect.y2 && compRect.y2 > selectionRect.y1);
              if (intersects) { itemsToSelect.push(comp); }
          });
          
          if (marquee.shiftKey) {
              itemsToSelect.forEach(item => addToSelection(item));
          } else {
              setSelection(itemsToSelect);
          }
      } else {
          if (!marquee.shiftKey) { clearSelection(); }
      }

      window.removeEventListener('mousemove', moveMarquee);
      window.removeEventListener('mouseup', endMarquee);
      marquee = null;
  }
  
  (function init(){
    state.screens = [{id: uid(), name: 'Schermo 1', canvas: { w:1920, h:1080 }, compositions: []}];
    state.activeScreenId = state.screens[0].id;
    updateScreenSelect();
    applyCanvasSize(1920,1080);
    canvasWInput.value = '1920'; canvasHInput.value = '1080';
    refreshRecap(); updateToolbarState();

    setupEditableValue(fontSizeValue, fontSizeSlider);
    setupEditableValue(nameOffsetXValue, nameOffsetXSlider);
    setupEditableValue(nameOffsetYValue, nameOffsetYSlider);

    applyVisibilityState();
  })();
  
})();

function renderTileLabels(el, cols, rows, tileW, tileH){
  el.querySelectorAll('.tile-label').forEach(n=>n.remove());
  const fs = Math.max(9, Math.floor(Math.min(tileW, tileH) * 0.28));
  for(let r=0; r<rows; r++){
    for(let c=0; c<cols; c++){
      const lab = document.createElement('div');
      lab.className = 'tile-label';
      lab.textContent = `${r+1}-${c+1}`;
      lab.style.left = (c*tileW) + 'px';
      lab.style.top  = (r*tileH) + 'px';
      lab.style.fontSize = fs + 'px';
      el.appendChild(lab);
    }
  }
}
</script>

<script>
  (function(){
    function safeName(s){
      return String(s||'').trim().replace(/[^a-z0-9_\-]+/gi,'_').replace(/^_+|_+$/g,'').toLowerCase() || 'screen';
    }
    
    function drawScreenToCanvas(scr, defaults, visibility){
      const w = Math.max(1, parseInt(scr.canvas?.w||1920,10));
      const h = Math.max(1, parseInt(scr.canvas?.h||1080,10));
      const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d'); ctx.imageSmoothingEnabled=false;
      ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
      let lineColor='#9fd7ff';
      try{ lineColor = getComputedStyle(document.documentElement).getPropertyValue('--tileLine').trim() || lineColor; }catch(e){}
      
      (scr.compositions||[]).forEach(comp=>{
        const x=Math.round(comp.x||0), y=Math.round(comp.y||0);
        const {cols, rows, tileW, tileH} = comp;
        const rectW = cols*tileW, rectH = rows*tileH;
        const count = comp.colorCount || 2;
        const base = (defaults&&defaults.colors) || ['#3b82f6','#10b981','#f97316','#ec4899'];
        const pal=(comp.colors||[]).map((c,i)=> c || base[i]).slice(0,count);
        
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            let col=pal[0];
            if(count===2) col=((r+c)%2===0)?pal[0]:pal[1];
            else if(count===3) col=pal[(r+c)%3];
            else if(count===4) col=pal[(r%2)*2 + (c%2)];
            const tx=x + c*tileW, ty=y + r*tileH;
            
            const borderWidth = visibility.tileLines ? 1 : 0;
            if (borderWidth > 0) { ctx.fillStyle=lineColor; ctx.fillRect(tx, ty, tileW, tileH); }
            
            const iw = tileW - (borderWidth*2), ih = tileH - (borderWidth*2);
            ctx.fillStyle = col;
            if (iw > 0 && ih > 0) { ctx.fillRect(tx + borderWidth, ty + borderWidth, iw, ih); } 
            else { ctx.fillRect(tx, ty, tileW, tileH); }
          }
        }

        const outline=3;
        ctx.fillStyle='#45b8ff'; 
        ctx.fillRect(x, y, rectW, outline); ctx.fillRect(x, y+rectH-outline, rectW, outline);
        ctx.fillRect(x, y, outline, rectH); ctx.fillRect(x+rectW-outline, y, outline, rectH);
      });
      
      (scr.compositions||[]).forEach(comp=>{
        const x=Math.round(comp.x||0), y=Math.round(comp.y||0);
        const {cols, rows, tileW, tileH} = comp;
        const rectW = cols*tileW, rectH = rows*tileH;
        const name = comp.name || '', nameCol = comp.nameColor || '#ffffff', sizeTxt = `${rectW}×${rectH}px`;
        const centerX = x + rectW/2, nameBaseY = y + rectH / 2, sizeBaseY = y + rectH - (tileH / 2);

        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.shadowColor='#000'; ctx.shadowBlur=4;
        
        if (visibility.name) {
          ctx.fillStyle=nameCol;
          const nameSize = comp.nameFontSize ? parseInt(comp.nameFontSize, 10) : 32;
          ctx.font = `bold ${nameSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
          const finalNameX = centerX + (parseInt(comp.nameOffsetX, 10) || 0);
          const verticalCorrection = nameSize * 0.1;
          const nudge = -4; 
          const finalNameY = nameBaseY + ((parseInt(comp.nameOffsetY, 10) || 0) * -1) + verticalCorrection + nudge;
          ctx.fillText(name, finalNameX, finalNameY);
        }

        if (visibility.size) {
          ctx.fillStyle=nameCol;
          const nameSizeForRef = comp.nameFontSize ? parseInt(comp.nameFontSize, 10) : 32;
          ctx.shadowBlur=3;
          const sizeFont = Math.max(10, Math.floor(nameSizeForRef*0.45));
          ctx.font = `bold ${sizeFont}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
          ctx.fillText(sizeTxt, centerX, sizeBaseY);
        }
        
        if(visibility.tileLabels) {
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              const tx=x + c*tileW, ty=y + r*tileH;
              const fs = Math.max(9, Math.min(28, Math.floor(Math.min(tileW, tileH)*0.28)));
              ctx.font = `bold ${fs}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
              ctx.textAlign = 'left'; ctx.textBaseline = 'top';
              ctx.fillStyle = '#fff'; ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
              ctx.fillText(`${r+1}-${c+1}`, tx+2, ty+2);
            }
          }
        }

        const offTL = `(${x},${y})`, offBR = `(${x + rectW - 1},${y + rectH - 1})`;
        const offMax = Math.max(10, Math.min(24, Math.floor(rectH*0.12)));
        ctx.fillStyle='#fff'; ctx.shadowColor='#000'; ctx.shadowBlur=2;
        ctx.font = `bold ${offMax}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        
        if (visibility.offsetTL) {
          ctx.textAlign='left'; ctx.textBaseline='top';
          ctx.fillText(offTL, x+6, y+30);
        }
        if (visibility.offsetBR) {
          ctx.textAlign='right'; ctx.textBaseline='bottom';
          ctx.fillText(offBR, x+rectW-6, y+rectH-6);
        }
        ctx.shadowBlur=0;
      });
      return cvs;
    }

    function exportPNGs(){
      const proj = window.collectProject(); 
      if(!proj || !proj.screens || !proj.screens.length){ alert('Nessuno schermo da esportare.'); return; }
      
      const visibilityState = window.state.visibility;
      const projName=safeName(proj.name||'progetto');
      const isIOS=/iPad|iPhone|iPod/.test(navigator.userAgent);
      
      proj.screens.forEach((scr,idx)=>{
        const can=drawScreenToCanvas(scr, proj.defaults, visibilityState);
        const filename=`${projName}_${safeName(scr.name||('screen_'+(idx+1)))}_${scr.canvas.w}x${scr.canvas.h}.png`;
        if(isIOS){
          const dataURL=can.toDataURL('image/png');
          const win=window.open();
          if(win){
            win.document.title=filename;
            const img=new Image(); img.src=dataURL; img.style='display:block;max-width:100%;height:auto;background:#000';
            win.document.body.style.margin='0'; win.document.body.style.background='#000';
            win.document.body.appendChild(img);
          }
        } else {
          can.toBlob((blob)=>{
            if(!blob) return;
            const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename;
            document.body.appendChild(a); a.click();
            setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
          }, 'image/png');
        }
      });
    }

    const btn=document.getElementById('exportBtn');
    if(btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); exportPNGs(); });
  })();
</script>

</body>
</html>
